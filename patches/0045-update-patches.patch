From db37e57266a15aa49f9a87964f84e74ce1d2de69 Mon Sep 17 00:00:00 2001
From: Martin Kibera <martin.kibera.n@gmail.com>
Date: Mon, 19 Jan 2026 16:08:28 +0300
Subject: [PATCH] update patches

---
 patches/0043-update-patches.patch           | 6305 +++++++++++++++++++
 patches/0044-add-music-videos-support.patch |   49 +
 2 files changed, 6354 insertions(+)
 create mode 100644 patches/0043-update-patches.patch
 create mode 100644 patches/0044-add-music-videos-support.patch

diff --git a/patches/0043-update-patches.patch b/patches/0043-update-patches.patch
new file mode 100644
index 0000000..d812e32
--- /dev/null
+++ b/patches/0043-update-patches.patch
@@ -0,0 +1,6305 @@
+From 90bf0569e201b9f8789ff5ed7db418e66fcc1b20 Mon Sep 17 00:00:00 2001
+From: Martin Kibera <martin.kibera.n@gmail.com>
+Date: Sat, 17 Jan 2026 19:19:54 +0300
+Subject: [PATCH] update patches
+
+---
+ patches/0041-update-patches.patch          | 6205 ++++++++++++++++++++
+ patches/0042-improve-audio-buffering.patch |   73 +
+ 2 files changed, 6278 insertions(+)
+ create mode 100644 patches/0041-update-patches.patch
+ create mode 100644 patches/0042-improve-audio-buffering.patch
+
+diff --git a/patches/0041-update-patches.patch b/patches/0041-update-patches.patch
+new file mode 100644
+index 0000000..d28cc12
+--- /dev/null
++++ b/patches/0041-update-patches.patch
+@@ -0,0 +1,6205 @@
++From e014fbf94f0e50c4b3c73d3391939637a9e15775 Mon Sep 17 00:00:00 2001
++From: Martin Kibera <martin.kibera.n@gmail.com>
++Date: Sat, 17 Jan 2026 14:54:01 +0300
++Subject: [PATCH] update patches
++
++---
++ patches/0038-update-patch-generation.patch    | 6023 +++++++++++++++++
++ .../0039-add-retry-to-replies-button.patch    |   85 +
++ patches/0040-update-docker-image-build.patch  |   62 +
++ 3 files changed, 6170 insertions(+)
++ create mode 100644 patches/0038-update-patch-generation.patch
++ create mode 100644 patches/0039-add-retry-to-replies-button.patch
++ create mode 100644 patches/0040-update-docker-image-build.patch
++
++diff --git a/patches/0038-update-patch-generation.patch b/patches/0038-update-patch-generation.patch
++new file mode 100644
++index 0000000..76d4ca7
++--- /dev/null
+++++ b/patches/0038-update-patch-generation.patch
++@@ -0,0 +1,6023 @@
+++From 8541004916e365caa9c2e327bad1789ab05f77d2 Mon Sep 17 00:00:00 2001
+++From: Martin Kibera <martin.kibera.n@gmail.com>
+++Date: Sat, 17 Jan 2026 10:16:44 +0300
+++Subject: [PATCH] update patch generation
+++
+++---
+++ patches/0001-stable-v1.patch                  |    4 +-
+++ patches/0002-fix-highlight-timestamps.patch   |    4 +-
+++ .../0003-fix-race-seek-playback-issue.patch   |    4 +-
+++ ...ix-more-pre-playback-race-conditions.patch |    4 +-
+++ .../0005-replace-b720p-with-just-720p.patch   |    4 +-
+++ ...dating-only-on-refresh-after-page-lo.patch |    4 +-
+++ ...-out-issues-caused-by-audio-load-lag.patch |    4 +-
+++ ...mber-selected-quality-within-session.patch |    4 +-
+++ patches/0009-fix-logging-spam.patch           |    4 +-
+++ ...10-fix-audio-stream-selection-issues.patch |    4 +-
+++ ...-consistently-even-after-url-refresh.patch |    4 +-
+++ patches/0012-tighten-video-audio-sync.patch   |    4 +-
+++ patches/0013-more-bug-buffering-fixes.patch   |    4 +-
+++ .../0014-preload-network-connections.patch    |    4 +-
+++ patches/0015-fix-seek-buffer-flickering.patch |    4 +-
+++ patches/0016-buffer-media-syncing-fixes.patch |    4 +-
+++ patches/0017-more-warmup-improvements.patch   |    4 +-
+++ patches/0018-fix-userInteracted.patch         |    4 +-
+++ .../0019-remove-sponsorblock-deadcode.patch   |    4 +-
+++ patches/0020-improve-seeking-audio-lag.patch  |    4 +-
+++ patches/0021-smoothen-playback-ux.patch       |    4 +-
+++ ...0022-fix-seeking-audio-disappearance.patch |    4 +-
+++ .../0023-Revert-smoothen-playback-ux.patch    |    4 +-
+++ patches/0024-more-state-mgt-fixes.patch       |    4 +-
+++ ...o-media-fetching-from-userInteracted.patch |    4 +-
+++ ...fix-make-video-follow-audio-playback.patch |    4 +-
+++ ...fix-make-video-follow-audio-playback.patch |    4 +-
+++ .../0028-fix-media-playback-race-issues.patch |    4 +-
+++ ...ce-alignment-polling-with-timeupdate.patch |    4 +-
+++ patches/0030-add-comments.patch               |    4 +-
+++ patches/0031-cleanup.patch                    |    4 +-
+++ patches/0032-patch-list.patch                 | 5248 +++++++++++++++++
+++ patches/0033-update-README.patch              |   47 +
+++ .../0034-buffer-audio-by-at-least-3s.patch    |   30 +
+++ ...handle-exception-from-comments-fetch.patch |   31 +
+++ ...0036-fix-non-resume-after-seek-issue.patch |   50 +
+++ ...bug-log-from-comment-fetch-exception.patch |   29 +
+++ scripts/sync-patches.sh                       |   56 +
+++ 38 files changed, 5553 insertions(+), 62 deletions(-)
+++ create mode 100644 patches/0032-patch-list.patch
+++ create mode 100644 patches/0033-update-README.patch
+++ create mode 100644 patches/0034-buffer-audio-by-at-least-3s.patch
+++ create mode 100644 patches/0035-handle-exception-from-comments-fetch.patch
+++ create mode 100644 patches/0036-fix-non-resume-after-seek-issue.patch
+++ create mode 100644 patches/0037-remove-debug-log-from-comment-fetch-exception.patch
+++ create mode 100644 scripts/sync-patches.sh
+++
+++diff --git a/patches/0001-stable-v1.patch b/patches/0001-stable-v1.patch
+++index 2589fe4..e5f50ed 100644
+++--- a/patches/0001-stable-v1.patch
++++++ b/patches/0001-stable-v1.patch
+++@@ -1,7 +1,7 @@
+++-From 7538f803d6ae25e6c7e711d6a7458665ef173b93 Mon Sep 17 00:00:00 2001
++++From 7391bee96d65ff1e7c2e67a101432b17126f8457 Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Fri, 24 Oct 2025 11:02:35 +0300
+++-Subject: [PATCH 01/31] stable v1
++++Subject: [PATCH] stable v1
+++ 
+++ ---
+++  api/video.js             | 315 ++++++++----------
+++diff --git a/patches/0002-fix-highlight-timestamps.patch b/patches/0002-fix-highlight-timestamps.patch
+++index 28a213d..929ece1 100644
+++--- a/patches/0002-fix-highlight-timestamps.patch
++++++ b/patches/0002-fix-highlight-timestamps.patch
+++@@ -1,7 +1,7 @@
+++-From 2ed5771a0233270ae11960279477343904f40d1f Mon Sep 17 00:00:00 2001
++++From f53ee996017caa6b61c554daac6e23f6a4bbbe85 Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Fri, 24 Oct 2025 12:19:23 +0300
+++-Subject: [PATCH 02/31] fix highlight timestamps
++++Subject: [PATCH] fix highlight timestamps
+++ 
+++ ---
+++  html/static/js/chapter-highlight.js | 69 +++++++++++++++++------------
+++diff --git a/patches/0003-fix-race-seek-playback-issue.patch b/patches/0003-fix-race-seek-playback-issue.patch
+++index ae17b4a..447da9a 100644
+++--- a/patches/0003-fix-race-seek-playback-issue.patch
++++++ b/patches/0003-fix-race-seek-playback-issue.patch
+++@@ -1,7 +1,7 @@
+++-From 53e8276085e3f93dc5d72c8f48b93c93c85d790d Mon Sep 17 00:00:00 2001
++++From d2b25361228310d7bfd2df9293f296063106f6eb Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Fri, 24 Oct 2025 14:15:31 +0300
+++-Subject: [PATCH 03/31] fix race seek/playback issue
++++Subject: [PATCH] fix race seek/playback issue
+++ 
+++ ---
+++  html/static/js/player.js | 51 +++++++++++++++++++++++++---------------
+++diff --git a/patches/0004-fix-more-pre-playback-race-conditions.patch b/patches/0004-fix-more-pre-playback-race-conditions.patch
+++index a1389a2..ddc2d62 100644
+++--- a/patches/0004-fix-more-pre-playback-race-conditions.patch
++++++ b/patches/0004-fix-more-pre-playback-race-conditions.patch
+++@@ -1,7 +1,7 @@
+++-From 6fa42c7c1d1c89d17e67bc7825ea736dcc85a730 Mon Sep 17 00:00:00 2001
++++From daa2843718cefedceb68b482322ac83e191deaf9 Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Sun, 26 Oct 2025 11:41:00 +0300
+++-Subject: [PATCH 04/31] fix more pre-playback race conditions
++++Subject: [PATCH] fix more pre-playback race conditions
+++ 
+++ ---
+++  html/static/js/player.js | 3 ++-
+++diff --git a/patches/0005-replace-b720p-with-just-720p.patch b/patches/0005-replace-b720p-with-just-720p.patch
+++index ba9784f..e6dfa3f 100644
+++--- a/patches/0005-replace-b720p-with-just-720p.patch
++++++ b/patches/0005-replace-b720p-with-just-720p.patch
+++@@ -1,7 +1,7 @@
+++-From 13716da489f4faf13edca5c45614904a9cb5e1a8 Mon Sep 17 00:00:00 2001
++++From 121ea8dadecd0435d6171d3ff2812cd58dda8c3c Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Sun, 26 Oct 2025 11:56:48 +0300
+++-Subject: [PATCH 05/31] replace b720p with just 720p
++++Subject: [PATCH] replace b720p with just 720p
+++ 
+++ ---
+++  pug/settings.pug | 3 +--
+++diff --git a/patches/0006-fix-timestamp-updating-only-on-refresh-after-page-lo.patch b/patches/0006-fix-timestamp-updating-only-on-refresh-after-page-lo.patch
+++index e205621..6ae8b0f 100644
+++--- a/patches/0006-fix-timestamp-updating-only-on-refresh-after-page-lo.patch
++++++ b/patches/0006-fix-timestamp-updating-only-on-refresh-after-page-lo.patch
+++@@ -1,7 +1,7 @@
+++-From e3d44ab9f6419939c5728829ba91d19dd7753fda Mon Sep 17 00:00:00 2001
++++From 77e118b6443616ff884cd52fef6b163b43849168 Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Thu, 30 Oct 2025 18:31:35 +0300
+++-Subject: [PATCH 06/31] fix timestamp updating only on refresh after page
++++Subject: [PATCH] fix timestamp updating only on refresh after page
+++  load/chapter click
+++ 
+++ ---
+++diff --git a/patches/0007-smoothen-out-issues-caused-by-audio-load-lag.patch b/patches/0007-smoothen-out-issues-caused-by-audio-load-lag.patch
+++index 9faa0cb..16a3506 100644
+++--- a/patches/0007-smoothen-out-issues-caused-by-audio-load-lag.patch
++++++ b/patches/0007-smoothen-out-issues-caused-by-audio-load-lag.patch
+++@@ -1,7 +1,7 @@
+++-From a97ef86f81b7a01fb1780d034a01552ef7dadcd4 Mon Sep 17 00:00:00 2001
++++From 3163395f4c291a90823ad77fb70eb64ea29f974a Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Mon, 17 Nov 2025 17:31:18 +0300
+++-Subject: [PATCH 07/31] smoothen out issues caused by audio load lag
++++Subject: [PATCH] smoothen out issues caused by audio load lag
+++ 
+++ ---
+++  html/static/js/player.js | 37 +++++++++++++++++++++----------------
+++diff --git a/patches/0008-remember-selected-quality-within-session.patch b/patches/0008-remember-selected-quality-within-session.patch
+++index bdcb307..07f3bf8 100644
+++--- a/patches/0008-remember-selected-quality-within-session.patch
++++++ b/patches/0008-remember-selected-quality-within-session.patch
+++@@ -1,7 +1,7 @@
+++-From 86b26d57166cf9d7f2d22747e52837781f58e1e8 Mon Sep 17 00:00:00 2001
++++From 33a90ee3b632d31f866d8a0fbbe146b42359096c Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Mon, 17 Nov 2025 19:48:03 +0300
+++-Subject: [PATCH 08/31] remember selected quality within session
++++Subject: [PATCH] remember selected quality within session
+++ 
+++ ---
+++  html/static/js/player.js | 101 ++++++++++++++++++++++++++++++++-------
+++diff --git a/patches/0009-fix-logging-spam.patch b/patches/0009-fix-logging-spam.patch
+++index ff7aa83..68b4ba9 100644
+++--- a/patches/0009-fix-logging-spam.patch
++++++ b/patches/0009-fix-logging-spam.patch
+++@@ -1,7 +1,7 @@
+++-From b399755f9b02bd4f6158593c7b3ea5b07a728bda Mon Sep 17 00:00:00 2001
++++From 5ed1ac5748c54c1006c7fdb1aa158d8ed4f70b5c Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Mon, 17 Nov 2025 19:59:17 +0300
+++-Subject: [PATCH 09/31] fix logging spam
++++Subject: [PATCH] fix logging spam
+++ 
+++ ---
+++  html/static/js/chapter-highlight.js | 1 +
+++diff --git a/patches/0010-fix-audio-stream-selection-issues.patch b/patches/0010-fix-audio-stream-selection-issues.patch
+++index 6c552cd..7b17281 100644
+++--- a/patches/0010-fix-audio-stream-selection-issues.patch
++++++ b/patches/0010-fix-audio-stream-selection-issues.patch
+++@@ -1,7 +1,7 @@
+++-From b35625238af17f71cf0d5a694dcfd68dc210e985 Mon Sep 17 00:00:00 2001
++++From 11dcc0f0f665b3367271f2e27f2fb4b643ac8204 Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Mon, 17 Nov 2025 21:28:33 +0300
+++-Subject: [PATCH 10/31] fix audio stream selection issues
++++Subject: [PATCH] fix audio stream selection issues
+++ 
+++ ---
+++  html/static/js/player.js | 16 +++++++++++++---
+++diff --git a/patches/0011-remember-quality-consistently-even-after-url-refresh.patch b/patches/0011-remember-quality-consistently-even-after-url-refresh.patch
+++index 3ec5f84..05dbc95 100644
+++--- a/patches/0011-remember-quality-consistently-even-after-url-refresh.patch
++++++ b/patches/0011-remember-quality-consistently-even-after-url-refresh.patch
+++@@ -1,7 +1,7 @@
+++-From 26ad8852d9c9ea500f60aefac43ddc922b4af525 Mon Sep 17 00:00:00 2001
++++From 18432b2ae476533571ae972da0d5e9d4793494fc Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Mon, 17 Nov 2025 21:38:32 +0300
+++-Subject: [PATCH 11/31] remember quality consistently even after url refresh
++++Subject: [PATCH] remember quality consistently even after url refresh
+++ 
+++ ---
+++  html/static/js/player.js | 17 ++++++++++-------
+++diff --git a/patches/0012-tighten-video-audio-sync.patch b/patches/0012-tighten-video-audio-sync.patch
+++index 4cc849e..22e48af 100644
+++--- a/patches/0012-tighten-video-audio-sync.patch
++++++ b/patches/0012-tighten-video-audio-sync.patch
+++@@ -1,7 +1,7 @@
+++-From 0caac7349908b3c26b699eaafc085676cafabe7e Mon Sep 17 00:00:00 2001
++++From 7cdd12a5593ae764e492b19e9b09252dab295e44 Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Mon, 17 Nov 2025 21:47:20 +0300
+++-Subject: [PATCH 12/31] tighten video+audio sync
++++Subject: [PATCH] tighten video+audio sync
+++ 
+++ ---
+++  html/static/js/player.js | 14 ++++++++++----
+++diff --git a/patches/0013-more-bug-buffering-fixes.patch b/patches/0013-more-bug-buffering-fixes.patch
+++index 6e3c974..4d468e4 100644
+++--- a/patches/0013-more-bug-buffering-fixes.patch
++++++ b/patches/0013-more-bug-buffering-fixes.patch
+++@@ -1,7 +1,7 @@
+++-From 6778843e215a0130ebd0aae312d2756e6036ff15 Mon Sep 17 00:00:00 2001
++++From d42c94c78d5a5a5f4e6db27d064f03574deea153 Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Mon, 24 Nov 2025 14:48:13 +0300
+++-Subject: [PATCH 13/31] more bug buffering fixes
++++Subject: [PATCH] more bug buffering fixes
+++ 
+++ ---
+++  html/static/js/player.js | 30 ++++++++++++++++++++----------
+++diff --git a/patches/0014-preload-network-connections.patch b/patches/0014-preload-network-connections.patch
+++index 704fec2..6dbfd54 100644
+++--- a/patches/0014-preload-network-connections.patch
++++++ b/patches/0014-preload-network-connections.patch
+++@@ -1,7 +1,7 @@
+++-From 85c497a0676abf4c2dad266046206f8636956fb6 Mon Sep 17 00:00:00 2001
++++From 67495032f8e437479c3c519294998ccb9efa3d28 Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Tue, 25 Nov 2025 23:28:19 +0300
+++-Subject: [PATCH 14/31] preload network connections
++++Subject: [PATCH] preload network connections
+++ 
+++ ---
+++  html/static/js/player.js | 34 ++++++++++++++++++++--------------
+++diff --git a/patches/0015-fix-seek-buffer-flickering.patch b/patches/0015-fix-seek-buffer-flickering.patch
+++index 3abaca0..9ac614a 100644
+++--- a/patches/0015-fix-seek-buffer-flickering.patch
++++++ b/patches/0015-fix-seek-buffer-flickering.patch
+++@@ -1,7 +1,7 @@
+++-From a46d7e803d9ec07ed3544a59307a4b008759e0b3 Mon Sep 17 00:00:00 2001
++++From d8c6bacb4d8e86e454b132f4c49e8b030cd56dde Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Sat, 29 Nov 2025 00:11:40 +0300
+++-Subject: [PATCH 15/31] fix seek buffer flickering
++++Subject: [PATCH] fix seek buffer flickering
+++ 
+++ ---
+++  html/static/js/player.js | 36 ++++++++++++++++++++++++++++++++++++
+++diff --git a/patches/0016-buffer-media-syncing-fixes.patch b/patches/0016-buffer-media-syncing-fixes.patch
+++index 380eecc..434717f 100644
+++--- a/patches/0016-buffer-media-syncing-fixes.patch
++++++ b/patches/0016-buffer-media-syncing-fixes.patch
+++@@ -1,7 +1,7 @@
+++-From 1341b5ce7ffeeff4f67b3b7888fbd6e5229e936a Mon Sep 17 00:00:00 2001
++++From 0aab8df67429703a1019ff36ffa3a794a2c7e7a5 Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Mon, 29 Dec 2025 21:29:54 +0300
+++-Subject: [PATCH 16/31] buffer + media syncing fixes
++++Subject: [PATCH] buffer + media syncing fixes
+++ 
+++ ---
+++  html/static/js/player.js | 12 ++++++++++--
+++diff --git a/patches/0017-more-warmup-improvements.patch b/patches/0017-more-warmup-improvements.patch
+++index 193192e..7d86547 100644
+++--- a/patches/0017-more-warmup-improvements.patch
++++++ b/patches/0017-more-warmup-improvements.patch
+++@@ -1,7 +1,7 @@
+++-From 70a5385a0e23464aa343534ac1cd7022daa0d6c9 Mon Sep 17 00:00:00 2001
++++From de99d35bb73c3b37b9c150f7688f68658e2b87d9 Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Fri, 2 Jan 2026 17:31:22 +0300
+++-Subject: [PATCH 17/31] more warmup improvements
++++Subject: [PATCH] more warmup improvements
+++ 
+++ ---
+++  html/static/js/player.js | 25 +++++++++++++++++++++----
+++diff --git a/patches/0018-fix-userInteracted.patch b/patches/0018-fix-userInteracted.patch
+++index c853fc0..148f9ba 100644
+++--- a/patches/0018-fix-userInteracted.patch
++++++ b/patches/0018-fix-userInteracted.patch
+++@@ -1,7 +1,7 @@
+++-From d883a2829d4dd0fcb1c3b3937463641bc54fe95f Mon Sep 17 00:00:00 2001
++++From ed85ac6af3538d4767c37eadcce83caf1473a1ed Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Sat, 10 Jan 2026 13:32:39 +0300
+++-Subject: [PATCH 18/31] fix userInteracted
++++Subject: [PATCH] fix userInteracted
+++ 
+++ ---
+++  html/static/js/player.js | 3 +++
+++diff --git a/patches/0019-remove-sponsorblock-deadcode.patch b/patches/0019-remove-sponsorblock-deadcode.patch
+++index 9067928..d45da78 100644
+++--- a/patches/0019-remove-sponsorblock-deadcode.patch
++++++ b/patches/0019-remove-sponsorblock-deadcode.patch
+++@@ -1,7 +1,7 @@
+++-From d83e89bd2cd64dbfa0f72da818f76030f4fd76af Mon Sep 17 00:00:00 2001
++++From 9d0e8f1f600c368dc5183c2e3c8368c34cb23003 Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Sat, 10 Jan 2026 13:59:57 +0300
+++-Subject: [PATCH 19/31] remove sponsorblock deadcode
++++Subject: [PATCH] remove sponsorblock deadcode
+++ 
+++ ---
+++  html/static/js/player.js | 11 +----------
+++diff --git a/patches/0020-improve-seeking-audio-lag.patch b/patches/0020-improve-seeking-audio-lag.patch
+++index a02e788..636b7f5 100644
+++--- a/patches/0020-improve-seeking-audio-lag.patch
++++++ b/patches/0020-improve-seeking-audio-lag.patch
+++@@ -1,7 +1,7 @@
+++-From 694ab576fed958e9c902a0f45490fedb75f9471a Mon Sep 17 00:00:00 2001
++++From 56f4aa2e89bb55b977c97c79e12a15bdde7d9ce1 Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Wed, 14 Jan 2026 14:23:49 +0300
+++-Subject: [PATCH 20/31] improve seeking audio lag
++++Subject: [PATCH] improve seeking audio lag
+++ 
+++ ---
+++  html/static/js/player.js | 4 +++-
+++diff --git a/patches/0021-smoothen-playback-ux.patch b/patches/0021-smoothen-playback-ux.patch
+++index dc4058f..d9876bc 100644
+++--- a/patches/0021-smoothen-playback-ux.patch
++++++ b/patches/0021-smoothen-playback-ux.patch
+++@@ -1,7 +1,7 @@
+++-From be0f5e6a1afa59f2f4223574341eb84e895f5226 Mon Sep 17 00:00:00 2001
++++From 80e4d4e3bb26d61f05ba0ff70d3e4d80b5836cdb Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Wed, 14 Jan 2026 16:58:45 +0300
+++-Subject: [PATCH 21/31] smoothen playback ux
++++Subject: [PATCH] smoothen playback ux
+++ 
+++ ---
+++  html/static/js/player.js | 38 ++++++++++++++++++++++++++++++++------
+++diff --git a/patches/0022-fix-seeking-audio-disappearance.patch b/patches/0022-fix-seeking-audio-disappearance.patch
+++index d870708..ffcab19 100644
+++--- a/patches/0022-fix-seeking-audio-disappearance.patch
++++++ b/patches/0022-fix-seeking-audio-disappearance.patch
+++@@ -1,7 +1,7 @@
+++-From 9a4f0a42383aaecc656f3ccb2a5f226dc38be43c Mon Sep 17 00:00:00 2001
++++From 4bdf094b1c8d4ee4f8c5134c6132b7163313c5a2 Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Thu, 15 Jan 2026 08:28:25 +0300
+++-Subject: [PATCH 22/31] fix seeking audio disappearance
++++Subject: [PATCH] fix seeking audio disappearance
+++ 
+++ ---
+++  html/static/js/player.js | 7 +++++++
+++diff --git a/patches/0023-Revert-smoothen-playback-ux.patch b/patches/0023-Revert-smoothen-playback-ux.patch
+++index 17f68b4..1b550d3 100644
+++--- a/patches/0023-Revert-smoothen-playback-ux.patch
++++++ b/patches/0023-Revert-smoothen-playback-ux.patch
+++@@ -1,7 +1,7 @@
+++-From 38fc8f04a6f39315e97e8f7458079f3bb9a3f18a Mon Sep 17 00:00:00 2001
++++From 6a5a89654669e83aac03a3a21360dad92f8927f1 Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Thu, 15 Jan 2026 09:12:42 +0300
+++-Subject: [PATCH 23/31] Revert "smoothen playback ux"
++++Subject: [PATCH] Revert "smoothen playback ux"
+++ 
+++ This reverts commit be0f5e6a1afa59f2f4223574341eb84e895f5226.
+++ ---
+++diff --git a/patches/0024-more-state-mgt-fixes.patch b/patches/0024-more-state-mgt-fixes.patch
+++index bb778c1..856c10a 100644
+++--- a/patches/0024-more-state-mgt-fixes.patch
++++++ b/patches/0024-more-state-mgt-fixes.patch
+++@@ -1,7 +1,7 @@
+++-From e24470042ace357fcaed748734036917e5ad44f9 Mon Sep 17 00:00:00 2001
++++From 237b4717cf1832393329d0ec70865530ac4705c8 Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Thu, 15 Jan 2026 10:21:19 +0300
+++-Subject: [PATCH 24/31] more state mgt fixes
++++Subject: [PATCH] more state mgt fixes
+++ 
+++ ---
+++  html/static/js/player.js | 20 +++++++++-----------
+++diff --git a/patches/0025-detach-audio-media-fetching-from-userInteracted.patch b/patches/0025-detach-audio-media-fetching-from-userInteracted.patch
+++index fa261b6..7c468e7 100644
+++--- a/patches/0025-detach-audio-media-fetching-from-userInteracted.patch
++++++ b/patches/0025-detach-audio-media-fetching-from-userInteracted.patch
+++@@ -1,7 +1,7 @@
+++-From 0034e2648ad2a7933530a38ce2211486f9ed4afa Mon Sep 17 00:00:00 2001
++++From 2820baf367e92f2954c2b1e6ae70ab150985d8dd Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Thu, 15 Jan 2026 12:31:56 +0300
+++-Subject: [PATCH 25/31] detach audio media fetching from userInteracted
++++Subject: [PATCH] detach audio media fetching from userInteracted
+++ 
+++ ---
+++  html/static/js/player.js | 48 ++++++++++++++++++++++++++++------------
+++diff --git a/patches/0026-finally-fix-make-video-follow-audio-playback.patch b/patches/0026-finally-fix-make-video-follow-audio-playback.patch
+++index ec5416a..42e3554 100644
+++--- a/patches/0026-finally-fix-make-video-follow-audio-playback.patch
++++++ b/patches/0026-finally-fix-make-video-follow-audio-playback.patch
+++@@ -1,7 +1,7 @@
+++-From b0111e3bf1ab97f8459b9bf0ee09e7d8476d7e17 Mon Sep 17 00:00:00 2001
++++From 19f09dfe271d5da42d82f6080a70eaabbd60b7b2 Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Thu, 15 Jan 2026 13:01:20 +0300
+++-Subject: [PATCH 26/31] finally fix make video follow audio playback
++++Subject: [PATCH] finally fix make video follow audio playback
+++ 
+++ ---
+++  html/static/js/player.js |  62 +++-
+++diff --git a/patches/0027-DRY-finally-fix-make-video-follow-audio-playback.patch b/patches/0027-DRY-finally-fix-make-video-follow-audio-playback.patch
+++index 1384512..ea3fa02 100644
+++--- a/patches/0027-DRY-finally-fix-make-video-follow-audio-playback.patch
++++++ b/patches/0027-DRY-finally-fix-make-video-follow-audio-playback.patch
+++@@ -1,7 +1,7 @@
+++-From 8d20f84b2133de09d444cfc814354ee4b539a8f8 Mon Sep 17 00:00:00 2001
++++From 38ea60837c984c73e028361de5053d6bcfb3b0d3 Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Thu, 15 Jan 2026 13:25:30 +0300
+++-Subject: [PATCH 27/31] DRY: finally fix make video follow audio playback
++++Subject: [PATCH] DRY: finally fix make video follow audio playback
+++ 
+++ ---
+++  html/static/js/player.js | 88 ++++++++++++++--------------------------
+++diff --git a/patches/0028-fix-media-playback-race-issues.patch b/patches/0028-fix-media-playback-race-issues.patch
+++index 288f212..910a036 100644
+++--- a/patches/0028-fix-media-playback-race-issues.patch
++++++ b/patches/0028-fix-media-playback-race-issues.patch
+++@@ -1,7 +1,7 @@
+++-From e018e0a7778df718c0283553b1b372b8537ec3ac Mon Sep 17 00:00:00 2001
++++From c8a7dec64ca24bf18b27b3831dd26fedf2774d0a Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Thu, 15 Jan 2026 18:42:46 +0300
+++-Subject: [PATCH 28/31] fix media playback race issues
++++Subject: [PATCH] fix media playback race issues
+++ 
+++ ---
+++  html/static/js/player.js | 43 ++++++++++++++++++++++++++++++----------
+++diff --git a/patches/0029-replace-alignment-polling-with-timeupdate.patch b/patches/0029-replace-alignment-polling-with-timeupdate.patch
+++index 8e7867b..a702054 100644
+++--- a/patches/0029-replace-alignment-polling-with-timeupdate.patch
++++++ b/patches/0029-replace-alignment-polling-with-timeupdate.patch
+++@@ -1,7 +1,7 @@
+++-From 60a326a1ec7821314646cd768179a16923be2078 Mon Sep 17 00:00:00 2001
++++From 398131fa3055ecc1d223ffb1f04172ff2f26818b Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Thu, 15 Jan 2026 21:06:42 +0300
+++-Subject: [PATCH 29/31] replace alignment polling with timeupdate
++++Subject: [PATCH] replace alignment polling with timeupdate
+++ 
+++ ---
+++  html/static/js/player.js | 11 ++++++-----
+++diff --git a/patches/0030-add-comments.patch b/patches/0030-add-comments.patch
+++index cf54ef7..6324e9e 100644
+++--- a/patches/0030-add-comments.patch
++++++ b/patches/0030-add-comments.patch
+++@@ -1,7 +1,7 @@
+++-From 5c6585c55ff434b593cde6df0296525ccf5adea7 Mon Sep 17 00:00:00 2001
++++From 590f92c28e3d28918c876f2ff926ef9ed0e0291b Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Fri, 16 Jan 2026 12:49:59 +0300
+++-Subject: [PATCH 30/31] add comments
++++Subject: [PATCH] add comments
+++ 
+++ ---
+++  api/video.js                   |  40 +++++++++-
+++diff --git a/patches/0031-cleanup.patch b/patches/0031-cleanup.patch
+++index eccd53b..8151073 100644
+++--- a/patches/0031-cleanup.patch
++++++ b/patches/0031-cleanup.patch
+++@@ -1,7 +1,7 @@
+++-From 9c7303d6848e98c4ee3386f7a5b89825e008aea4 Mon Sep 17 00:00:00 2001
++++From 2d58e9290237f09c09331383e0416dcb55356450 Mon Sep 17 00:00:00 2001
+++ From: Martin Kibera <martin.kibera.n@gmail.com>
+++ Date: Fri, 16 Jan 2026 13:45:23 +0300
+++-Subject: [PATCH 31/31] cleanup
++++Subject: [PATCH] cleanup
+++ 
+++ ---
+++  new.player.5 | 745 ---------------------------------------------------
+++diff --git a/patches/0032-patch-list.patch b/patches/0032-patch-list.patch
+++new file mode 100644
+++index 0000000..dce7ad6
+++--- /dev/null
++++++ b/patches/0032-patch-list.patch
+++@@ -0,0 +1,5248 @@
++++From 84155fb29251da59428d558a3e5f382402ca2614 Mon Sep 17 00:00:00 2001
++++From: Martin Kibera <martin.kibera.n@gmail.com>
++++Date: Fri, 16 Jan 2026 16:33:14 +0300
++++Subject: [PATCH] patch list
++++
++++---
++++ patches/0001-stable-v1.patch                  | 1148 +++++++++++++++++
++++ patches/0002-fix-highlight-timestamps.patch   |  127 ++
++++ .../0003-fix-race-seek-playback-issue.patch   |  129 ++
++++ ...ix-more-pre-playback-race-conditions.patch |   33 +
++++ .../0005-replace-b720p-with-just-720p.patch   |   26 +
++++ ...dating-only-on-refresh-after-page-lo.patch |   32 +
++++ ...-out-issues-caused-by-audio-load-lag.patch |  127 ++
++++ ...mber-selected-quality-within-session.patch |  156 +++
++++ patches/0009-fix-logging-spam.patch           |   24 +
++++ ...10-fix-audio-stream-selection-issues.patch |   63 +
++++ ...-consistently-even-after-url-refresh.patch |   53 +
++++ patches/0012-tighten-video-audio-sync.patch   |   46 +
++++ patches/0013-more-bug-buffering-fixes.patch   |   52 +
++++ .../0014-preload-network-connections.patch    |   85 ++
++++ patches/0015-fix-seek-buffer-flickering.patch |   59 +
++++ patches/0016-buffer-media-syncing-fixes.patch |   50 +
++++ patches/0017-more-warmup-improvements.patch   |   58 +
++++ patches/0018-fix-userInteracted.patch         |   36 +
++++ .../0019-remove-sponsorblock-deadcode.patch   |   41 +
++++ patches/0020-improve-seeking-audio-lag.patch  |   27 +
++++ patches/0021-smoothen-playback-ux.patch       |   96 ++
++++ ...0022-fix-seeking-audio-disappearance.patch |   30 +
++++ .../0023-Revert-smoothen-playback-ux.patch    |   97 ++
++++ patches/0024-more-state-mgt-fixes.patch       |   63 +
++++ ...o-media-fetching-from-userInteracted.patch |   84 ++
++++ ...fix-make-video-follow-audio-playback.patch |  852 ++++++++++++
++++ ...fix-make-video-follow-audio-playback.patch |  142 ++
++++ .../0028-fix-media-playback-race-issues.patch |   92 ++
++++ ...ce-alignment-polling-with-timeupdate.patch |   45 +
++++ patches/0030-add-comments.patch               |  352 +++++
++++ patches/0031-cleanup.patch                    |  764 +++++++++++
++++ 31 files changed, 4989 insertions(+)
++++ create mode 100644 patches/0001-stable-v1.patch
++++ create mode 100644 patches/0002-fix-highlight-timestamps.patch
++++ create mode 100644 patches/0003-fix-race-seek-playback-issue.patch
++++ create mode 100644 patches/0004-fix-more-pre-playback-race-conditions.patch
++++ create mode 100644 patches/0005-replace-b720p-with-just-720p.patch
++++ create mode 100644 patches/0006-fix-timestamp-updating-only-on-refresh-after-page-lo.patch
++++ create mode 100644 patches/0007-smoothen-out-issues-caused-by-audio-load-lag.patch
++++ create mode 100644 patches/0008-remember-selected-quality-within-session.patch
++++ create mode 100644 patches/0009-fix-logging-spam.patch
++++ create mode 100644 patches/0010-fix-audio-stream-selection-issues.patch
++++ create mode 100644 patches/0011-remember-quality-consistently-even-after-url-refresh.patch
++++ create mode 100644 patches/0012-tighten-video-audio-sync.patch
++++ create mode 100644 patches/0013-more-bug-buffering-fixes.patch
++++ create mode 100644 patches/0014-preload-network-connections.patch
++++ create mode 100644 patches/0015-fix-seek-buffer-flickering.patch
++++ create mode 100644 patches/0016-buffer-media-syncing-fixes.patch
++++ create mode 100644 patches/0017-more-warmup-improvements.patch
++++ create mode 100644 patches/0018-fix-userInteracted.patch
++++ create mode 100644 patches/0019-remove-sponsorblock-deadcode.patch
++++ create mode 100644 patches/0020-improve-seeking-audio-lag.patch
++++ create mode 100644 patches/0021-smoothen-playback-ux.patch
++++ create mode 100644 patches/0022-fix-seeking-audio-disappearance.patch
++++ create mode 100644 patches/0023-Revert-smoothen-playback-ux.patch
++++ create mode 100644 patches/0024-more-state-mgt-fixes.patch
++++ create mode 100644 patches/0025-detach-audio-media-fetching-from-userInteracted.patch
++++ create mode 100644 patches/0026-finally-fix-make-video-follow-audio-playback.patch
++++ create mode 100644 patches/0027-DRY-finally-fix-make-video-follow-audio-playback.patch
++++ create mode 100644 patches/0028-fix-media-playback-race-issues.patch
++++ create mode 100644 patches/0029-replace-alignment-polling-with-timeupdate.patch
++++ create mode 100644 patches/0030-add-comments.patch
++++ create mode 100644 patches/0031-cleanup.patch
++++
++++diff --git a/patches/0001-stable-v1.patch b/patches/0001-stable-v1.patch
++++new file mode 100644
++++index 0000000..2589fe4
++++--- /dev/null
+++++++ b/patches/0001-stable-v1.patch
++++@@ -0,0 +1,1148 @@
+++++From 7538f803d6ae25e6c7e711d6a7458665ef173b93 Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Fri, 24 Oct 2025 11:02:35 +0300
+++++Subject: [PATCH 01/31] stable v1
+++++
+++++---
+++++ api/video.js             | 315 ++++++++----------
+++++ html/static/js/player.js | 690 +++++++++++++++++++++++++++------------
+++++ pug/settings.pug         |   5 +-
+++++ 3 files changed, 606 insertions(+), 404 deletions(-)
+++++
+++++diff --git a/api/video.js b/api/video.js
+++++index 1389c99..859ca0a 100644
+++++--- a/api/video.js
++++++++ b/api/video.js
+++++@@ -1,246 +1,187 @@
+++++-const {request} = require("../utils/request")
++++++const {request} = require("../utils/request");
+++++ /** @type {import("node-fetch").default} */
+++++ // @ts-ignore
+++++-const fetch = require("node-fetch")
+++++-const {render} = require("pinski/plugins")
+++++-const db = require("../utils/db")
+++++-const {getToken, getUser} = require("../utils/getuser")
+++++-const pug = require("pug")
+++++-const converters = require("../utils/converters")
+++++-const constants = require("../utils/constants")
++++++const fetch = require("node-fetch");
++++++const {render} = require("pinski/plugins");
++++++const db = require("../utils/db");
++++++const {getToken, getUser} = require("../utils/getuser");
++++++const pug = require("pug");
++++++const converters = require("../utils/converters");
++++++const constants = require("../utils/constants");
+++++ 
+++++ class InstanceError extends Error {
+++++ 	constructor(error, identifier) {
+++++-		super(error)
+++++-		this.identifier = identifier
++++++		super(error);
++++++		this.identifier = identifier;
+++++ 	}
+++++ }
+++++ 
+++++-class MessageError extends Error {
+++++-}
++++++class MessageError extends Error {}
+++++ 
+++++ function formatOrder(format) {
+++++-	// most significant to least significant
+++++-	// key, max, order, transform
+++++-	// asc: lower number comes first, desc: higher number comes first
+++++ 	const spec = [
+++++-		{key: "second__height", max: 8000, order: "desc", transform: x => x ? Math.floor(x/96) : 0},
+++++-		{key: "fps", max: 100, order: "desc", transform: x => x ? Math.floor(x/10) : 0},
++++++		{key: "second__height", max: 8000, order: "desc", transform: x => (x ? Math.floor(x / 96) : 0)},
++++++		{key: "fps", max: 100, order: "desc", transform: x => (x ? Math.floor(x / 10) : 0)},
+++++ 		{key: "type", max: " ".repeat(60), order: "asc", transform: x => x.length}
+++++-	]
+++++-	let total = 0
+++++-	for (let i = 0; i < spec.length; i++) {
+++++-		const s = spec[i]
+++++-		let diff = s.transform(format[s.key])
+++++-		if (s.order === "asc") diff = s.transform(s.max) - diff
+++++-		total += diff
+++++-		if (i+1 < spec.length) { // not the last spec item?
+++++-			const s2 = spec[i+1]
+++++-			total *= s2.transform(s2.max)
++++++	];
++++++
++++++	return spec.reduce((total, s, i) => {
++++++		let diff = s.transform(format[s.key]);
++++++		if (s.order === "asc") diff = s.transform(s.max) - diff;
++++++		total += diff;
++++++		if (i + 1 < spec.length) {
++++++			total *= spec[i + 1].transform(spec[i + 1].max);
+++++ 		}
+++++-	}
+++++-	return -total
++++++		return total;
++++++	}, 0) * -1;
+++++ }
+++++ 
+++++ function sortFormats(video, preference) {
+++++-	// Add second__ extensions to format objects, required if Invidious was the extractor
+++++-	let formats = video.formatStreams.concat(video.adaptiveFormats)
+++++-	for (const format of formats) {
+++++-		if (!format.second__height && format.resolution) format.second__height = +format.resolution.slice(0, -1)
+++++-		if (!format.second__order) format.second__order = formatOrder(format)
+++++-		format.cloudtube__label = `${format.qualityLabel} ${format.container}`
+++++-	}
++++++	const {formatStreams, adaptiveFormats} = video;
++++++	let formats = [...formatStreams, ...adaptiveFormats];
+++++ 
+++++-	// Properly build and order format list
+++++-	const standard = video.formatStreams.slice().sort((a, b) => b.second__height - a.second__height)
+++++-	const adaptive = video.adaptiveFormats.filter(f => f.type.startsWith("video") && f.qualityLabel).sort((a, b) => a.second__order - b.second__order)
+++++-	for (const format of adaptive) {
+++++-		if (!format.cloudtube__label.endsWith("*")) format.cloudtube__label += " *"
+++++-	}
+++++-	formats = standard.concat(adaptive)
+++++-
+++++-	// Reorder fomats based on user preference
+++++-	if (preference === 1) { // best dash
+++++-		formats.sort((a, b) => {
+++++-			const a1 = a.second__height + a.fps / 100
+++++-			const b1 = b.second__height + b.fps / 100
+++++-			return b1 - a1
+++++-		})
+++++-	} else if (preference === 2) { // best <=1080p
+++++-		formats.sort((a, b) => {
+++++-			const a1 = a.second__height + a.fps / 100
+++++-			const b1 = b.second__height + b.fps / 100
+++++-			if (b1 > 1081) {
+++++-				if (a1 > 1081) return b1 - a1
+++++-				return -1
+++++-			}
+++++-			if (a1 > 1081) return 1
+++++-			return b1 - a1
+++++-		})
+++++-	} else if (preference === 3) { // best low-fps
+++++-		formats.sort((a, b) => {
+++++-			if (b.fps > 30) {
+++++-				if (a.fps < 30) return b.second__height - a.second__height
+++++-				return -1
+++++-			}
+++++-			if (a.fps > 30) return 1
+++++-			return b.second__height - a.second__height
+++++-		})
+++++-	} else if (preference === 4) { // 360p only
+++++-		formats.sort((a, b) => {
+++++-			if (a.itag == 18) return -1
+++++-			if (b.itag == 18) return 1
+++++-			return 0
+++++-		})
+++++-	} else { // preference === 0, best combined
+++++-		// should already be correct
++++++	formats.forEach(format => {
++++++		if (!format.second__height && format.resolution) {
++++++			format.second__height = +format.resolution.slice(0, -1);
++++++		}
++++++		if (!format.second__order) {
++++++			format.second__order = formatOrder(format);
++++++		}
++++++		format.cloudtube__label = `${format.qualityLabel} ${format.container}`;
++++++	});
++++++
++++++	const standard = [...formatStreams].sort((a, b) => b.second__height - a.second__height);
++++++	const adaptive = adaptiveFormats
++++++		.filter(f => f.type.startsWith("video") && f.qualityLabel)
++++++		.map(f => ({...f, cloudtube__label: `${f.cloudtube__label} *`}))
++++++		.sort((a, b) => a.second__order - b.second__order);
++++++
++++++	formats = [...standard, ...adaptive];
++++++
++++++	const preferenceSorters = {
++++++		5: (a, b) => (b.second__height + b.fps / 100) - (a.second__height + a.fps / 100),
++++++		2: (a, b) => {
++++++			const a1 = a.second__height + a.fps / 100;
++++++			const b1 = b.second__height + b.fps / 100;
++++++			if (b1 > 1081) return a1 > 1081 ? b1 - a1 : -1;
++++++			if (a1 > 1081) return 1;
++++++			return b1 - a1;
++++++		},
++++++		1: (a, b) => {
++++++			const a1 = a.second__height + a.fps / 100;
++++++			const b1 = b.second__height + b.fps / 100;
++++++			if (b1 > 721) return a1 > 721 ? b1 - a1 : -1;
++++++			if (a1 > 721) return 1;
++++++			return b1 - a1;
++++++		},
++++++		3: (a, b) => {
++++++			if (b.fps > 30) return a.fps < 30 ? b.second__height - a.second__height : -1;
++++++			if (a.fps > 30) return 1;
++++++			return b.second__height - a.second__height;
++++++		},
++++++		4: (a, b) => (a.itag === 18 ? -1 : b.itag === 18 ? 1 : 0)
++++++	};
++++++
++++++	if (preference in preferenceSorters) {
++++++		formats.sort(preferenceSorters[preference]);
+++++ 	}
+++++ 
+++++-	return formats
++++++	return formats;
+++++ }
+++++ 
+++++ module.exports = [
+++++ 	{
+++++ 		route: "/watch", methods: ["GET", "POST"], upload: true, code: async ({req, url, body}) => {
+++++-			// Prepare data needed to render video page
+++++-
+++++-			const user = getUser(req)
+++++-			const settings = user.getSettingsOrDefaults()
+++++-			const id = url.searchParams.get("v")
++++++			const user = getUser(req);
++++++			const settings = user.getSettingsOrDefaults();
++++++			const id = url.searchParams.get("v");
+++++ 
+++++-			// Check if should watch on YouTube
+++++ 			if (settings.local === 2) {
+++++-				const dest = `https://www.youtube.com${url.pathname}${url.search}#cloudtube`
+++++-				user.addWatchedVideoMaybe(id)
++++++				const dest = `https://www.youtube.com${url.pathname}${url.search}#cloudtube`;
++++++				user.addWatchedVideoMaybe(id);
+++++ 				return {
+++++ 					statusCode: 302,
+++++ 					contentType: "text/plain",
+++++-					headers: {
+++++-						"Location": dest
+++++-					},
++++++					headers: {"Location": dest},
+++++ 					content: `Redirecting to ${dest}...`
+++++-				}
++++++				};
+++++ 			}
+++++ 
+++++-			// Check if playback is allowed
+++++-			const videoTakedownInfo = db.prepare("SELECT id, org, url FROM TakedownVideos WHERE id = ?").get(id)
++++++			const videoTakedownInfo = db.prepare("SELECT id, org, url FROM TakedownVideos WHERE id = ?").get(id);
+++++ 			if (videoTakedownInfo) {
+++++-				return render(451, "pug/takedown-video.pug", Object.assign({req, settings}, videoTakedownInfo))
++++++				return render(451, "pug/takedown-video.pug", {...videoTakedownInfo, req, settings});
+++++ 			}
+++++ 
+++++-			// Media fragment
+++++-			const t = url.searchParams.get("t")
+++++-			let mediaFragment = converters.tToMediaFragment(t)
+++++-
+++++-			// Continuous mode
+++++-			const continuous = url.searchParams.get("continuous") === "1"
+++++-			const autoplay = url.searchParams.get("autoplay") === "1"
+++++-			const swp = url.searchParams.get("session-watched")
+++++-			const sessionWatched = swp ? swp.split(" ") : []
+++++-			const sessionWatchedNext = sessionWatched.concat([id]).join("+")
+++++-			if (continuous) settings.quality = 0 // autoplay with synced streams does not work
+++++-
+++++-			// Work out how to fetch the video
+++++-			if (req.method === "GET") {
+++++-				if (settings.local === 1) { // skip to the local fetching page, which will then POST video data in a moment
+++++-					return render(200, "pug/local-video.pug", {req, settings, id})
+++++-				}
+++++-				var instanceOrigin = settings.instance
+++++-				var outURL = `${instanceOrigin}/api/v1/videos/${id}`
+++++-				var videoFuture = request(outURL).then(res => res.json())
+++++-			} else { // req.method === "POST"
+++++-				var instanceOrigin = "http://localhost:3000"
+++++-				var videoFuture = JSON.parse(new URLSearchParams(body.toString()).get("video"))
+++++-			}
++++++			const t = url.searchParams.get("t");
++++++			const mediaFragment = converters.tToMediaFragment(t);
++++++			const continuous = url.searchParams.get("continuous") === "1";
++++++			const autoplay = url.searchParams.get("autoplay") === "1";
++++++			const swp = url.searchParams.get("session-watched");
++++++			const sessionWatched = swp ? swp.split(" ") : [];
++++++			const sessionWatchedNext = [...sessionWatched, id].join("+");
++++++			if (continuous) settings.quality = 0;
+++++ 
+++++-			try {
+++++-				// Fetch the video
+++++-				const video = await videoFuture
++++++			const instanceOrigin = settings.local === 1 ? "http://localhost:3000" : settings.instance;
++++++			const videoFuture = req.method === "GET"
++++++				? request(`${instanceOrigin}/api/v1/videos/${id}`).then(res => res.json())
++++++				: JSON.parse(new URLSearchParams(body.toString()).get("video"));
+++++ 
+++++-				// Error handling
+++++-				if (!video) throw new MessageError("The instance returned null.")
+++++-				if (video.error) throw new InstanceError(video.error, video.identifier)
++++++			try {
++++++				const video = await videoFuture;
++++++				if (!video) throw new MessageError("The instance returned null.");
++++++				if (video.error) throw new InstanceError(video.error, video.identifier);
+++++ 
+++++-				// Check if channel playback is allowed
+++++-				const channelTakedownInfo = db.prepare("SELECT ucid, org, url FROM TakedownChannels WHERE ucid = ?").get(video.authorId)
++++++				const channelTakedownInfo = db.prepare("SELECT ucid, org, url FROM TakedownChannels WHERE ucid = ?").get(video.authorId);
+++++ 				if (channelTakedownInfo) {
+++++-					// automatically add the entry to the videos list, so it won't be fetched again
+++++-					const args = {id, ...channelTakedownInfo}
+++++-					db.prepare("INSERT INTO TakedownVideos (id, org, url) VALUES (@id, @org, @url)").run(args)
+++++-					return render(451, "pug/takedown-video.pug", Object.assign({req, settings}, channelTakedownInfo))
+++++-				}
+++++-
+++++-				// process stream list ordering
+++++-				const formats = sortFormats(video, settings.quality)
+++++-
+++++-				// process length text and view count
+++++-				for (const rec of video.recommendedVideos) {
+++++-					converters.normaliseVideoInfo(rec)
++++++					db.prepare("INSERT INTO TakedownVideos (id, org, url) VALUES (@id, @org, @url)").run({id, ...channelTakedownInfo});
++++++					return render(451, "pug/takedown-video.pug", {...channelTakedownInfo, req, settings});
+++++ 				}
+++++ 
+++++-				// filter list
+++++-				const {videos, filteredCount} = converters.applyVideoFilters(video.recommendedVideos, user.getFilters())
+++++-				video.recommendedVideos = videos
++++++				const formats = sortFormats(video, settings.quality);
+++++ 
+++++-				// get subscription data
+++++-				const subscribed = user.isSubscribed(video.authorId)
++++++				video.recommendedVideos.forEach(converters.normaliseVideoInfo);
++++++				const {videos, filteredCount} = converters.applyVideoFilters(video.recommendedVideos, user.getFilters());
++++++				video.recommendedVideos = videos;
+++++ 
+++++-				// process watched videos
+++++-				user.addWatchedVideoMaybe(video.videoId)
+++++-				const watchedVideos = user.getWatchedVideos()
++++++				const subscribed = user.isSubscribed(video.authorId);
++++++				user.addWatchedVideoMaybe(video.videoId);
++++++				const watchedVideos = user.getWatchedVideos();
+++++ 				if (watchedVideos.length) {
+++++-					for (const rec of video.recommendedVideos) {
+++++-						rec.watched = watchedVideos.includes(rec.videoId)
+++++-					}
++++++					video.recommendedVideos.forEach(rec => {
++++++						rec.watched = watchedVideos.includes(rec.videoId);
++++++					});
+++++ 				}
+++++ 
+++++-				// normalise view count
+++++ 				if (!video.second__viewCountText && video.viewCount) {
+++++-					video.second__viewCountText = converters.viewCountToText(video.viewCount)
++++++					video.second__viewCountText = new Intl.NumberFormat().format(video.viewCount);
+++++ 				}
+++++ 
+++++-				// apply media fragment to all sources
+++++-				for (const format of formats) {
+++++-					format.url += mediaFragment
+++++-				}
++++++				formats.forEach(format => {
++++++					format.url += mediaFragment;
++++++				});
+++++ 
+++++-				// rewrite description
+++++-				video.descriptionHtml = converters.rewriteVideoDescription(video.descriptionHtml, id)
+++++-
+++++-				// rewrite captions urls so they are served on the same domain via the /proxy route
+++++-				for (const caption of video.captions) {
+++++-					caption.url = `/proxy?${new URLSearchParams({"url": caption.url})}`
+++++-				}
++++++				video.descriptionHtml = converters.rewriteVideoDescription(video.descriptionHtml, id);
++++++				video.captions.forEach(caption => {
++++++					caption.url = `/proxy?${new URLSearchParams({url: caption.url})}`;
++++++				});
+++++ 
+++++ 				return render(200, "pug/video.pug", {
+++++ 					req, url, video, formats, subscribed, instanceOrigin, mediaFragment, autoplay, continuous,
+++++ 					sessionWatched, sessionWatchedNext, settings
+++++-				})
++++++				});
+++++ 
+++++ 			} catch (error) {
+++++-				// Something went wrong, somewhere! Find out where.
+++++-
+++++-				let errorType = "unrecognised-error"
+++++-				const locals = {instanceOrigin, error}
+++++-
+++++-				// Sort error category
+++++-				if (error instanceof fetch.FetchError) {
+++++-					errorType = "fetch-error"
+++++-				} else if (error instanceof MessageError) {
+++++-					errorType = "message-error"
+++++-				} else if (error instanceof InstanceError) {
+++++-					if (error.identifier === "RATE_LIMITED_BY_YOUTUBE" || error.message === "Could not extract video info. Instance is likely blocked.") {
+++++-						errorType = "rate-limited"
+++++-					} else {
+++++-						errorType = "instance-error"
+++++-					}
+++++-				}
+++++-
+++++-				// Create appropriate formatted message
+++++-				const message = render(0, `pug/errors/${errorType}.pug`, locals).content
+++++-
+++++-				return render(500, "pug/video.pug", {video: {videoId: id}, error: true, message, req, settings})
++++++				const errorTypeMap = {
++++++					"fetch-error": error instanceof fetch.FetchError,
++++++					"message-error": error instanceof MessageError,
++++++					"rate-limited": error instanceof InstanceError && (error.identifier === "RATE_LIMITED_BY_YOUTUBE" || error.message === "Could not extract video info. Instance is likely blocked."),
++++++					"instance-error": error instanceof InstanceError
++++++				};
++++++				const errorType = Object.keys(errorTypeMap).find(key => errorTypeMap[key]) || "unrecognised-error";
++++++				const message = render(0, `pug/errors/${errorType}.pug`, {instanceOrigin, error}).content;
++++++
++++++				return render(500, "pug/video.pug", {video: {videoId: id}, error: true, message, req, settings});
+++++ 			}
+++++ 		}
+++++ 	}
+++++-]
++++++];
+++++\ No newline at end of file
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index f053224..3fff9d9 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -1,250 +1,510 @@
+++++-import {q, qa, ElemJS} from "/static/js/elemjs/elemjs.js"
+++++-import {SubscribeButton} from "/static/js/modules/SubscribeButton.js"
++++++import { q, qa, ElemJS } from "/static/js/elemjs/elemjs.js";
++++++import { SubscribeButton } from "/static/js/modules/SubscribeButton.js";
+++++ 
+++++-const video = q("#video")
+++++-const audio = q("#audio")
++++++const videoElement = q("#video");
++++++const audioElement = q("#audio");
++++++// Buffer audio aggressively
++++++audioElement.preload = "auto";
+++++ 
+++++-const videoFormats = new Map()
+++++-const audioFormats = new Map()
+++++-for (const f of [].concat(
+++++-	data.formatStreams.map(f => (f.isAdaptive = false, f)),
+++++-	data.adaptiveFormats.map(f => (f.isAdaptive = true, f))
+++++-)) {
+++++-	if (f.type.startsWith("video")) {
+++++-		videoFormats.set(f.itag, f)
+++++-	} else {
+++++-		audioFormats.set(f.itag, f)
+++++-	}
+++++-}
++++++// Make video focusable
++++++videoElement.setAttribute("tabindex", "0");
++++++
++++++let userInteracted = false;
++++++document.addEventListener("click", () => { userInteracted = true; }, { once: true });
++++++
++++++let syncCheckInterval = null;
++++++const videoFormats = new Map();
++++++const audioFormats = [];
++++++
++++++[...data.formatStreams, ...data.adaptiveFormats].forEach(f => {
++++++    f.isAdaptive = f.type.startsWith("video");
++++++    if (f.type.startsWith("video")) {
++++++        videoFormats.set(f.itag, f);
++++++    } else {
++++++        audioFormats.push(f);
++++++    }
++++++});
+++++ 
+++++ function getBestAudioFormat() {
+++++-	let best = null
+++++-	let aidub = false
+++++-	for (const f of audioFormats.values()) {
+++++-		if (f.resolution.includes("default")) {
+++++-			aidub = true
+++++-		}
+++++-	}
+++++-	for (const f of audioFormats.values()) {
+++++-		if (!aidub || f.resolution.includes("default")) {
+++++-			if (best === null || f.bitrate > best.bitrate) {
+++++-				best = f
+++++-			}
+++++-		}
+++++-	}
+++++-	return best
++++++    function parseXtags(url) {
++++++        const urlParams = new URLSearchParams(url.split('?')[1] ?? '');
++++++        const xtags = urlParams.get('xtags') ?? '';
++++++        const parts = xtags.split(':');
++++++        let language = 'unknown';
++++++        let content = 'unknown';
++++++        for (const part of parts) {
++++++            if (part.startsWith('lang=')) {
++++++                language = part.replace('lang=', '');
++++++                if (language.includes('-')) language = language.split('-')[0];
++++++            }
++++++            if (part.startsWith('acont=')) content = part.replace('acont=', '');
++++++        }
++++++        return { language, content };
++++++    }
++++++
++++++    let best = null;
++++++
++++++    for (const f of audioFormats) {
++++++        if (!isValidUrl(f.url)) continue;
++++++        const { language, content } = parseXtags(f.url);
++++++        if (language === 'en' && content === 'original') {
++++++            if (!best || f.bitrate > best.bitrate) {
++++++                best = f;
++++++            }
++++++        }
++++++    }
++++++
++++++    if (!best) {
++++++        for (const f of audioFormats) {
++++++            if (!isValidUrl(f.url)) continue;
++++++            const { language } = parseXtags(f.url);
++++++            if (language === 'en') {
++++++                if (!best || f.bitrate > best.bitrate) {
++++++                    best = f;
++++++                }
++++++            }
++++++        }
++++++    }
++++++
++++++    if (!best) {
++++++        for (const f of audioFormats) {
++++++            if (!isValidUrl(f.url)) continue;
++++++            if (!best || f.bitrate > best.bitrate) {
++++++                best = f;
++++++            }
++++++        }
++++++    }
++++++
++++++    return best;
++++++}
++++++
++++++function isValidUrl(string) {
++++++    try {
++++++        new URL(string);
++++++        return true;
++++++    } catch (_) {
++++++        return false;
++++++    }
++++++}
++++++
++++++function loadMediaWithRetry(mediaElement, url, retries = 6) {
++++++    let attempt = 0;
++++++    let locked = false; // lock once playback ever begins
++++++
++++++    const load = () => {
++++++        if (locked) return; // never reload after playback has started
++++++
++++++        mediaElement.src = url;
++++++        mediaElement.load();
++++++
++++++        // Lock out retries once playback begins
++++++        mediaElement.onplaying = () => {
++++++            locked = true;
++++++        };
++++++
++++++        mediaElement.oncanplay = () => {
++++++            // Also lock out once its ready to play (in case play() isnt called yet)
++++++            locked = true;
++++++        };
++++++
++++++        mediaElement.onerror = () => {
++++++            if (locked) return; // ignore errors after lock
++++++
++++++            attempt++;
++++++            if (attempt < retries) {
++++++                setTimeout(load, 4000 * attempt);
++++++            } else {
++++++                console.error("Failed to load media after", retries, "attempts.");
++++++            }
++++++        };
++++++    };
++++++
++++++    load();
+++++ }
+++++ 
++++++let pipReady = false;
++++++
++++++document.addEventListener("visibilitychange", async () => {
++++++    const video = document.querySelector("video");
++++++    if (!video || !document.pictureInPictureEnabled) return;
++++++
++++++    if (document.hidden && !document.pictureInPictureElement && !video.paused) {
++++++        if (!pipReady) {
++++++            console.warn("PiP blocked. Waiting for user gesture to enable re-entry.");
++++++            return;
++++++        }
++++++
++++++        try {
++++++            await video.requestPictureInPicture();
++++++        } catch (err) {
++++++            console.error("PiP request failed:", err);
++++++        }
++++++    }
++++++});
++++++
++++++document.addEventListener("leavepictureinpicture", () => {
++++++    pipReady = false;
++++++});
++++++
++++++document.addEventListener("click", () => {
++++++    pipReady = true;
++++++});
++++++
++++++const audioContext = new AudioContext();
++++++
+++++ class FormatLoader {
+++++-	constructor() {
+++++-		this.npv = videoFormats.get(q("#video").getAttribute("data-itag"))
+++++-		this.npa = null
+++++-	}
+++++-
+++++-	play(itag) {
+++++-		this.npv = videoFormats.get(itag)
+++++-		if (this.npv.isAdaptive) {
+++++-			this.npa = getBestAudioFormat()
+++++-		} else {
+++++-			this.npa = null
+++++-		}
+++++-		this.update()
+++++-	}
+++++-
+++++-	update() {
+++++-		const lastTime = video.currentTime
+++++-		video.src = this.npv.url
+++++-		video.currentTime = lastTime
+++++-		if (this.npa) {
+++++-			audio.src = this.npa.url
+++++-			audio.pause()
+++++-			audio.currentTime = lastTime
+++++-		} else {
+++++-			audio.pause()
+++++-			audio.removeAttribute("src")
+++++-		}
+++++-	}
+++++-}
+++++-
+++++-const formatLoader = new FormatLoader()
++++++    constructor() {
++++++        this.npv = videoFormats.get(videoElement.getAttribute("data-itag"));
++++++        this.npa = null;
++++++    }
++++++
++++++    play(itag) {
++++++        this.npv = videoFormats.get(itag);
++++++        this.npa = null;
++++++
++++++        // Only attach separate audio if the stream has no audio codec
++++++        const hasAudio = this.npv.type && (this.npv.type.includes("mp4a") || this.npv.type.includes("audio"));
++++++        if (!hasAudio) {
++++++            const bestAudio = getBestAudioFormat();
++++++            if (bestAudio && bestAudio.url !== this.npv.url) {
++++++                this.npa = bestAudio;
++++++            }
++++++        }
++++++
++++++        this.update();
++++++    }
++++++
++++++    update() {
++++++        cleanupSync();
++++++        const lastTime = videoElement.currentTime;
++++++
++++++        loadMediaWithRetry(videoElement, this.npv.url);
++++++        videoElement.currentTime = lastTime;
++++++
++++++        if (this.npa) {
++++++            audioElement.pause();
++++++            audioElement.src = "";
++++++            loadMediaWithRetry(audioElement, this.npa.url);
++++++            audioElement.currentTime = lastTime;
++++++        } else {
++++++            audioElement.pause();
++++++            audioElement.removeAttribute("src");
++++++        }
++++++    }
++++++}
++++++
++++++
++++++const formatLoader = new FormatLoader();
+++++ 
+++++ class PlayManager {
+++++-	constructor(media, isAudio) {
+++++-		this.media = media
+++++-		this.isAudio = isAudio
+++++-	}
++++++    constructor(media, isAudio) {
++++++        this.media = media;
++++++        this.isAudio = isAudio;
++++++    }
+++++ 
+++++-	isActive() {
+++++-		return !this.isAudio || formatLoader.npa
+++++-	}
++++++    isActive() {
++++++        return !this.isAudio || formatLoader.npa;
++++++    }
+++++ 
+++++-	play() {
+++++-		if (this.isActive()) this.media.play()
+++++-	}
++++++    play() {
++++++        if (this.isActive()) this.media.play();
++++++    }
+++++ 
+++++-	pause() {
+++++-		if (this.isActive()) this.media.pause()
+++++-	}
++++++    pause() {
++++++        if (this.isActive()) this.media.pause();
++++++    }
+++++ }
+++++ 
+++++ const playManagers = {
+++++-	video: new PlayManager(video, false),
+++++-	audio: new PlayManager(audio, true)
+++++-}
++++++    video: new PlayManager(videoElement, false),
++++++    audio: new PlayManager(audioElement, true)
++++++};
+++++ 
+++++ class QualitySelect extends ElemJS {
+++++-	constructor() {
+++++-		super(q("#quality-select"))
+++++-		this.on("input", this.setFormat.bind(this))
+++++-		this.setFormat()
+++++-	}
++++++    constructor() {
++++++        super(q("#quality-select"));
++++++        this.on("input", this.setFormat.bind(this));
++++++        this.setFormat();
++++++    }
++++++
++++++    setFormat() {
++++++        const itag = this.element.value;
++++++        formatLoader.play(itag);
++++++        videoElement.focus();
++++++    }
++++++}
++++++
++++++new QualitySelect();
+++++ 
+++++-	setFormat() {
+++++-		const itag = this.element.value
+++++-		formatLoader.play(itag)
+++++-		video.focus()
+++++-	}
++++++const ignoreNext = { play: 0 };
++++++
++++++function startSyncCheck() {
++++++    if (syncCheckInterval) clearInterval(syncCheckInterval);
++++++    syncCheckInterval = setInterval(() => {
++++++        if (!videoElement.paused && !audioElement.paused) {
++++++            const drift = Math.abs(videoElement.currentTime - audioElement.currentTime);
++++++            if (drift > 0.1) {
++++++                audioElement.currentTime = videoElement.currentTime;
++++++            }
++++++        }
++++++    }, 1000);
+++++ }
+++++ 
+++++-const qualitySelect = new QualitySelect()
++++++function stopSyncCheck() {
++++++    if (syncCheckInterval) clearInterval(syncCheckInterval);
++++++    syncCheckInterval = null;
++++++}
+++++ 
+++++-const ignoreNext = {
+++++-	play: 0
++++++function cleanupSync() {
++++++    stopSyncCheck();
+++++ }
+++++ 
++++++videoElement.addEventListener("play", startSyncCheck);
++++++videoElement.addEventListener("pause", stopSyncCheck);
++++++
++++++// --- SponsorBlock skip fix
++++++let sponsorSkipInProgress = false; // flag to track SB skip
++++++
++++++// Wrap SponsorBlock skips by listening for its events
++++++document.addEventListener("SponsorBlockSkip", () => {
++++++    sponsorSkipInProgress = true;
++++++    setTimeout(() => { sponsorSkipInProgress = false; }, 100); // short debounce
++++++});
++++++
+++++ function playbackIntervention(event) {
+++++-	console.log(event.target.tagName.toLowerCase(), event.type)
+++++-	if (audio.src) {
+++++-		let target = event.target
+++++-		let other = (event.target === video ? audio : video)
+++++-		let targetPlayManager = playManagers[target.tagName.toLowerCase()]
+++++-		let otherPlayManager = playManagers[other.tagName.toLowerCase()]
+++++-		if (ignoreNext[event.type] > 0) {
+++++-			ignoreNext[event.type]--
+++++-			return
+++++-		}
+++++-		switch (event.type) {
+++++-		case "durationchange":
+++++-			target.ready = false;
+++++-			break;
+++++-		case "seeked":
+++++-			target.ready = false;
+++++-			target.pause();
+++++-			other.currentTime = target.currentTime;
+++++-			break;
+++++-		case "play":
+++++-			other.currentTime = target.currentTime;
+++++-			otherPlayManager.play();
+++++-			break;
+++++-		case "pause":
+++++-			other.currentTime = target.currentTime;
+++++-			other.pause();
+++++-		case "playing":
+++++-			other.currentTime = target.currentTime;
+++++-			break;
+++++-		case "ratechange":
+++++-			other.playbackRate = target.playbackRate;
+++++-			break;
+++++-		// case "stalled":
+++++-		// case "waiting":
+++++-			// target.pause();
+++++-			// break;
+++++-		}
+++++-	} else {
+++++-		// @ts-ignore this does exist
+++++-		// if (event.type == "canplaythrough" && !video.manualPaused) video.play();
+++++-	}
+++++-}
+++++-
+++++-for (let eventName of ["pause", "play", "seeked"]) {
+++++-	video.addEventListener(eventName, playbackIntervention)
+++++-}
+++++-for (let eventName of ["canplaythrough", "waiting", "stalled", "ratechange"]) {
+++++-	video.addEventListener(eventName, playbackIntervention)
+++++-	audio.addEventListener(eventName, playbackIntervention)
++++++    const target = event.target;
++++++    const other = target === videoElement ? audioElement : videoElement;
++++++
++++++    // Only sync audio for non-SB manual seeks
++++++    if (!sponsorSkipInProgress && audioElement.src && !ignoreNext[event.type]--) {
++++++        if (event.type === "seeked") {
++++++            const targetTime = target.currentTime;
++++++            other.currentTime = targetTime;
++++++
++++++            setTimeout(() => {
++++++                if (Math.abs(videoElement.currentTime - audioElement.currentTime) > 0.1) {
++++++                    videoElement.currentTime = targetTime;
++++++                    audioElement.currentTime = targetTime;
++++++                }
++++++            }, 100);
++++++        } else if (event.type === "play") {
++++++            playManagers[other.tagName.toLowerCase()].play();
++++++        } else if (event.type === "pause") {
++++++            other.pause();
++++++        } else if (event.type === "ratechange") {
++++++            other.playbackRate = target.playbackRate;
++++++        }
++++++    }
+++++ }
+++++ 
++++++function debounce(func, wait) {
++++++    let timeoutId;
++++++    return (...args) => {
++++++        clearTimeout(timeoutId);
++++++        timeoutId = setTimeout(() => func(...args), wait);
++++++    };
++++++}
++++++
++++++const debouncedPlaybackIntervention = debounce(playbackIntervention, 100);
++++++["pause", "play", "seeked"].forEach(eventName =>
++++++    videoElement.addEventListener(eventName, debouncedPlaybackIntervention)
++++++);
++++++["canplaythrough", "waiting", "stalled", "ratechange"].forEach(eventName => {
++++++    videoElement.addEventListener(eventName, playbackIntervention);
++++++    audioElement.addEventListener(eventName, playbackIntervention);
++++++});
++++++
++++++// Error handling
++++++videoElement.addEventListener("error", (e) => {
++++++    console.error("Video loading error:", e);
++++++});
++++++audioElement.addEventListener("error", (e) => {
++++++    console.error("Audio loading error:", e);
++++++});
++++++
++++++// Loading feedback
++++++videoElement.addEventListener("waiting", () => console.log("Video buffering..."));
++++++audioElement.addEventListener("waiting", () => console.log("Audio buffering..."));
++++++
++++++// Fix reverb on buffering mid-playback
++++++// --- Robust mid-playback buffering isolation ---
++++++let wasPlayingBeforeBuffer = false;
++++++
++++++videoElement.addEventListener("waiting", () => {
++++++    if (!videoElement.paused && videoElement.currentTime > 0) {
++++++        wasPlayingBeforeBuffer = true;
++++++
++++++        if (!audioElement.paused && formatLoader.npa) {
++++++            audioElement.muted = true;
++++++        }
++++++    }
++++++});
++++++
++++++videoElement.addEventListener("playing", () => {
++++++    if (wasPlayingBeforeBuffer && formatLoader.npa) {
++++++        wasPlayingBeforeBuffer = false;
++++++        audioElement.muted = false;
++++++        audioElement.currentTime = videoElement.currentTime;
++++++    }
++++++});
++++++
++++++
++++++const videoObserver = new IntersectionObserver((entries) => {
++++++    entries.forEach(entry => {
++++++        if (entry.isIntersecting) {
++++++            loadMediaWithRetry(videoElement, formatLoader.npv.url);
++++++            if (formatLoader.npa) {
++++++                loadMediaWithRetry(audioElement, formatLoader.npa.url);
++++++            }
++++++            videoObserver.disconnect();
++++++        }
++++++    });
++++++}, { threshold: 0.5 });
++++++
++++++videoObserver.observe(videoElement);
++++++
+++++ function relativeSeek(seconds) {
+++++-	video.currentTime += seconds
++++++    videoElement.currentTime += seconds;
+++++ }
+++++ 
+++++-function playVideo() {
+++++-	audio.currentTime = video.currentTime
+++++-	let lastTime = video.currentTime
+++++-	ignoreNext.play++
+++++-	video.play().then(() => {
+++++-		const interval = setInterval(() => {
+++++-			console.log("checking video", video.currentTime, lastTime)
+++++-			if (video.currentTime !== lastTime) {
+++++-				clearInterval(interval)
+++++-				playManagers.audio.play()
+++++-				return
+++++-			}
+++++-		}, 15)
+++++-	})
++++++async function playVideo() {
++++++    if (!userInteracted) return; //  prevent auto play before click/gesture
++++++    if (!videoElement.paused) return;
++++++
++++++    audioElement.currentTime = videoElement.currentTime;
++++++    ignoreNext.play++;
++++++
++++++    try {
++++++        if (audioContext.state === 'suspended') {
++++++            await audioContext.resume();
++++++        }
++++++
++++++        await videoElement.play();
++++++        if (playManagers.audio.isActive() && audioElement.src) {
++++++            await audioElement.play();
++++++        }
++++++    } catch (e) {
++++++        console.error("Video play failed", e);
++++++    }
+++++ }
+++++ 
+++++ function togglePlaying() {
+++++-	if (video.paused) playVideo()
+++++-	else video.pause()
++++++    if (videoElement.paused) {
++++++        playVideo();
++++++    } else {
++++++        videoElement.pause();
++++++    }
+++++ }
+++++ 
+++++ function toggleFullScreen() {
+++++-	if (document.fullscreen) document.exitFullscreen()
+++++-	else video.requestFullscreen()
+++++-}
+++++-
+++++-video.addEventListener("click", event => {
+++++-	event.preventDefault()
+++++-	togglePlaying()
+++++-})
+++++-
+++++-video.addEventListener("dblclick", event => {
+++++-	event.preventDefault()
+++++-	toggleFullScreen()
+++++-})
+++++-
+++++-document.addEventListener("keydown", event => {
+++++-	if (["INPUT", "SELECT", "BUTTON"].includes(event.target.tagName)) return
+++++-	if (event.ctrlKey || event.shiftKey || event.altKey || event.metaKey) return
+++++-	let caught = true
+++++-	if (event.key === "j" || event.key === "n") {
+++++-		relativeSeek(-10)
+++++-	} else if (["k", "p", " ", "e"].includes(event.key)) {
+++++-		togglePlaying()
+++++-	} else if (event.key === "l" || event.key === "o") {
+++++-		relativeSeek(10)
+++++-	} else if (event.key === "ArrowLeft") {
+++++-		relativeSeek(-5)
+++++-	} else if (event.key === "ArrowRight") {
+++++-		relativeSeek(5)
+++++-	} else if (event.key >= "0" && event.key <= "9") {
+++++-		video.currentTime = video.duration * (+event.key) / 10
+++++-	} else if (event.key === "f") {
+++++-		toggleFullScreen()
+++++-	} else {
+++++-		caught = false
+++++-	}
+++++-	if (caught) event.preventDefault()
+++++-})
+++++-
+++++-new SubscribeButton(q("#subscribe"))
+++++-
+++++-const timestamps = qa("[data-clickable-timestamp]")
+++++-
+++++-class Timestamp extends ElemJS {
+++++-	constructor(element) {
+++++-		super(element)
+++++-		this.on("click", this.onClick.bind(this))
+++++-	}
+++++-
+++++-	onClick(event) {
+++++-		event.preventDefault()
+++++-		video.currentTime = event.target.getAttribute("data-clickable-timestamp")
+++++-		window.history.replaceState(null, "", event.target.href)
+++++-	}
+++++-}
+++++-
+++++-timestamps.forEach(el => {
+++++-	new Timestamp(el)
+++++-})
++++++    if (document.fullscreenElement || document.webkitFullscreenElement) {
++++++        (document.exitFullscreen || document.webkitExitFullscreen).call(document);
++++++    } else {
++++++        (videoElement.requestFullscreen || videoElement.webkitRequestFullscreen).call(videoElement);
++++++    }
++++++}
++++++
++++++//  Critical: Track interaction and refocus
++++++videoElement.addEventListener("pointerdown", () => {
++++++    videoElement.focus();
++++++});
++++++
++++++videoElement.addEventListener("click", (event) => {
++++++    event.preventDefault();
++++++    togglePlaying();
++++++    videoElement.lastInteraction = Date.now(); // Track last click
++++++    videoElement.focus();
++++++});
++++++
++++++//  Capture spacebar early and forcefully
++++++const keyActions = new Map([
++++++    ["j", () => relativeSeek(-10)],
++++++    ["n", () => relativeSeek(-10)],
++++++    ["k", togglePlaying],
++++++    ["p", togglePlaying],
++++++    [" ", togglePlaying],
++++++    ["e", togglePlaying],
++++++    ["l", () => relativeSeek(10)],
++++++    ["o", () => relativeSeek(10)],
++++++    ["ArrowLeft", () => relativeSeek(-5)],
++++++    ["ArrowRight", () => relativeSeek(5)],
++++++    ["f", toggleFullScreen]
++++++]);
++++++
++++++// Use capture phase to intercept spacebar before browser scrolls
++++++document.addEventListener("keydown", async (event) => {
++++++    // Ignore inputs and Ctrl combinations
++++++    if (["INPUT", "SELECT", "TEXTAREA", "BUTTON"].includes(event.target.tagName) || event.ctrlKey) {
++++++        return;
++++++    }
++++++
++++++    if (event.key === "k") {
++++++        event.preventDefault();
++++++
++++++        // Track last interaction so other logic (like spacebar) sees a gesture
++++++        videoElement.lastInteraction = Date.now();
++++++
++++++        // Attempt to play video and audio
++++++        try {
++++++            if (videoElement.paused) {
++++++                await videoElement.play(); // counts as user gesture
++++++                if (audioElement.src && playManagers.audio.isActive()) {
++++++                    try {
++++++                        await audioElement.play();
++++++                    } catch (e) {
++++++                        console.warn("Audio blocked until user gesture:", e);
++++++                    }
++++++                }
++++++            } else {
++++++                videoElement.pause();
++++++                audioElement.pause();
++++++            }
++++++        } catch (e) {
++++++            console.warn("Playback blocked by browser:", e);
++++++        }
++++++
++++++        return; // prevent further handling
++++++    }
++++++
++++++    const action = keyActions.get(event.key);
++++++    if (action) {
++++++        if (event.key === " ") {
++++++            const isActive = document.activeElement === videoElement;
++++++            const recentlyClicked = Date.now() - (videoElement.lastInteraction || 0) < 15000;
++++++            if (!isActive && !recentlyClicked) return;
++++++            event.preventDefault();
++++++        }
++++++
++++++        action();
++++++        event.preventDefault();
++++++    }
++++++}, true); // capture phase: critical for gesture detection
++++++
++++++
++++++if ('mediaSession' in navigator) {
++++++    navigator.mediaSession.metadata = new MediaMetadata({
++++++        title: 'Video Title',
++++++        artist: 'Artist Name',
++++++        album: 'Album Name',
++++++    });
++++++
++++++    navigator.mediaSession.setActionHandler('play', togglePlaying);
++++++    navigator.mediaSession.setActionHandler('pause', togglePlaying);
++++++}
++++++
++++++videoElement.setAttribute('preload', 'metadata');
++++++audioElement.setAttribute('preload', 'metadata');
++++++
++++++new SubscribeButton(q("#subscribe"));
++++++
++++++document.addEventListener('click', (event) => {
++++++    const timestampEl = event.target.closest('[data-clickable-timestamp]');
++++++    if (timestampEl) {
++++++        event.preventDefault();
++++++        const time = parseFloat(timestampEl.getAttribute('data-clickable-timestamp'));
++++++        if (!isNaN(time)) {
++++++            videoElement.currentTime = time;
++++++            window.history.replaceState(null, '', timestampEl.href);
++++++        }
++++++    }
++++++});
+++++\ No newline at end of file
+++++diff --git a/pug/settings.pug b/pug/settings.pug
+++++index f504dba..d56de25 100644
+++++--- a/pug/settings.pug
++++++++ b/pug/settings.pug
+++++@@ -71,9 +71,10 @@ block content
+++++           label: "Preferred qualities",
+++++           description: "All qualities are available on the watch page. This defines their sort order.",
+++++           options: [
++++++            {value: "1", text: "b720p"},
+++++             {value: "0", text: "720p"},
+++++             {value: "4", text: "360p"},
+++++-            {value: "1", text: "Best possible"},
++++++            {value: "5", text: "Best possible"},
+++++             {value: "2", text: "Best <=1080p"},
+++++             {value: "3", text: "Best <=30fps"}
+++++           ]
+++++@@ -137,4 +138,4 @@ block content
+++++           label(for="delete-confirm").delete-confirm-label I understand the consequences
+++++         form(method="post" action="/formapi/erase")
+++++           input(type="hidden" name="token" value=user.token)
+++++-          button.border-look#delete-button Permanently erase my data
++++++          button.border-look#delete-button Permanently erase my data
+++++\ No newline at end of file
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0002-fix-highlight-timestamps.patch b/patches/0002-fix-highlight-timestamps.patch
++++new file mode 100644
++++index 0000000..28a213d
++++--- /dev/null
+++++++ b/patches/0002-fix-highlight-timestamps.patch
++++@@ -0,0 +1,127 @@
+++++From 2ed5771a0233270ae11960279477343904f40d1f Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Fri, 24 Oct 2025 12:19:23 +0300
+++++Subject: [PATCH 02/31] fix highlight timestamps
+++++
+++++---
+++++ html/static/js/chapter-highlight.js | 69 +++++++++++++++++------------
+++++ utils/converters.js                 |  6 ++-
+++++ 2 files changed, 45 insertions(+), 30 deletions(-)
+++++
+++++diff --git a/html/static/js/chapter-highlight.js b/html/static/js/chapter-highlight.js
+++++index 5b44cd9..d87ecd3 100644
+++++--- a/html/static/js/chapter-highlight.js
++++++++ b/html/static/js/chapter-highlight.js
+++++@@ -1,4 +1,4 @@
+++++-import {q, qa, ElemJS} from "./elemjs/elemjs.js"
++++++import {q, ElemJS} from "./elemjs/elemjs.js"
+++++ 
+++++ class Chapter {
+++++ 	constructor(linkElement) {
+++++@@ -7,47 +7,58 @@ class Chapter {
+++++ 	}
+++++ }
+++++ 
+++++-let chapters = [...document.querySelectorAll("[data-clickable-timestamp]")].map(linkElement => new Chapter(linkElement))
++++++let chapters = [...document.querySelectorAll("[data-clickable-timestamp]")]
++++++    .map(el => new Chapter(el))
+++++ chapters.sort((a, b) => a.time - b.time)
+++++ 
+++++-function getCurrentChapter(time) {
+++++-	const candidates = chapters.filter(chapter => chapter.time <= time)
+++++-	if (candidates.length > 0) {
+++++-		return candidates[candidates.length - 1]
+++++-	} else {
+++++-		return null
+++++-	}
+++++-}
+++++-
+++++ const video = q("#video")
+++++ const description = q("#description")
+++++ const regularBackground = "var(--regular-background)"
+++++ const highlightBackground = "var(--highlight-background)"
+++++ const paddingWidth = 4
+++++ let lastChapter = null
+++++-setInterval(() => {
+++++-	const currentChapter = getCurrentChapter(video.currentTime)
+++++ 
++++++function getCurrentChapter(time) {
++++++	const candidates = chapters.filter(ch => ch.time <= time)
++++++	return candidates.length ? candidates[candidates.length - 1] : null
++++++}
++++++
++++++function updateHighlight() {
++++++	const currentChapter = getCurrentChapter(video.currentTime)
+++++ 	if (currentChapter !== lastChapter) {
+++++-		// Style link
+++++-		if (lastChapter) {
+++++-			lastChapter.link.removeClass("timestamp--active")
+++++-		}
+++++-		if (currentChapter) {
+++++-			currentChapter.link.class("timestamp--active")
+++++-		}
+++++-		// Style background
++++++		if (lastChapter) lastChapter.link.removeClass("timestamp--active")
++++++		//if (currentChapter) currentChapter.link.addClass("timestamp--active")
++++++
+++++ 		if (currentChapter) {
+++++-			const {offsetTop, offsetHeight} = currentChapter.link.element;
++++++			const {offsetTop, offsetHeight} = currentChapter.link.element
+++++ 			const offsetBottom = offsetTop + offsetHeight
+++++-			let gradient = `linear-gradient(to bottom,`
+++++-				+ ` ${regularBackground} ${offsetTop - paddingWidth}px, ${highlightBackground} ${offsetTop - paddingWidth}px,`
+++++-				+ ` ${highlightBackground} ${offsetBottom + paddingWidth}px, ${regularBackground} ${offsetBottom + paddingWidth}px)`
+++++-			console.log(gradient)
+++++-			description.style.background = gradient
++++++			description.style.background =
++++++				`linear-gradient(to bottom, ${regularBackground} ${offsetTop - paddingWidth}px, ${highlightBackground} ${offsetTop - paddingWidth}px, ${highlightBackground} ${offsetBottom + paddingWidth}px, ${regularBackground} ${offsetBottom + paddingWidth}px)`
+++++ 		} else {
+++++ 			description.style.background = ""
+++++ 		}
++++++		lastChapter = currentChapter
+++++ 	}
+++++-	lastChapter = currentChapter
+++++-}, 1000)
++++++}
++++++
++++++setInterval(updateHighlight, 250)
++++++
++++++document.addEventListener('click', e => {
++++++	const timestampEl = e.target.closest('[data-clickable-timestamp]')
++++++	if (!timestampEl) return
++++++
++++++	e.preventDefault()
++++++	const time = parseFloat(timestampEl.getAttribute('data-clickable-timestamp'))
++++++	if (isNaN(time)) return
++++++
++++++	video.currentTime = time
++++++
++++++	// Convert seconds to YouTube-style t=XmYs
++++++	const minutes = Math.floor(time / 60)
++++++	const seconds = Math.floor(time % 60)
++++++	const tParam = `${minutes}m${seconds}s`
++++++
++++++	const url = new URL(window.location)
++++++	url.searchParams.set('t', tParam)
++++++	window.history.replaceState(null, '', url)
++++++})
+++++diff --git a/utils/converters.js b/utils/converters.js
+++++index 84e4535..c92f37d 100644
+++++--- a/utils/converters.js
++++++++ b/utils/converters.js
+++++@@ -94,7 +94,11 @@ function rewriteVideoDescription(descriptionHtml, id) {
+++++ 		params.set("t", timeURL)
+++++ 		const url = "/watch?" + params
+++++ 
+++++-		return timeDisplayCompiled({url, timeURL, timeDisplay, timeSeconds})
++++++		// Ensure the data-clickable-timestamp attribute contains a plain
++++++		// numeric string (seconds). Passing a string avoids cases where the
++++++		// attribute could contain formats like "3:00" or "3m00s" which
++++++		// front-end parseFloat would misinterpret (e.g. parseFloat("3:00") === 3).
++++++		return timeDisplayCompiled({url, timeURL, timeDisplay, timeSeconds: String(timeSeconds)})
+++++ 	})
+++++ 
+++++ 	return descriptionHtml
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0003-fix-race-seek-playback-issue.patch b/patches/0003-fix-race-seek-playback-issue.patch
++++new file mode 100644
++++index 0000000..ae17b4a
++++--- /dev/null
+++++++ b/patches/0003-fix-race-seek-playback-issue.patch
++++@@ -0,0 +1,129 @@
+++++From 53e8276085e3f93dc5d72c8f48b93c93c85d790d Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Fri, 24 Oct 2025 14:15:31 +0300
+++++Subject: [PATCH 03/31] fix race seek/playback issue
+++++
+++++---
+++++ html/static/js/player.js | 51 +++++++++++++++++++++++++---------------
+++++ 1 file changed, 32 insertions(+), 19 deletions(-)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index 3fff9d9..b6efd17 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -89,27 +89,27 @@ function isValidUrl(string) {
+++++ 
+++++ function loadMediaWithRetry(mediaElement, url, retries = 6) {
+++++     let attempt = 0;
+++++-    let locked = false; // lock once playback ever begins
++++++    let locked = false;
++++++    let reloading = false; // prevent rapid reload loops
+++++ 
+++++     const load = () => {
+++++-        if (locked) return; // never reload after playback has started
++++++        if (locked || reloading) return;
++++++        reloading = true;
++++++
++++++        // prevent immediate consecutive reloads
++++++        setTimeout(() => { reloading = false; }, 3000);
++++++
++++++        // if element already has usable buffered data, skip reload
++++++        if (mediaElement.readyState >= 3 && !mediaElement.error) return;
+++++ 
+++++         mediaElement.src = url;
+++++         mediaElement.load();
+++++ 
+++++-        // Lock out retries once playback begins
+++++-        mediaElement.onplaying = () => {
+++++-            locked = true;
+++++-        };
+++++-
+++++-        mediaElement.oncanplay = () => {
+++++-            // Also lock out once its ready to play (in case play() isnt called yet)
+++++-            locked = true;
+++++-        };
++++++        mediaElement.onplaying = () => { locked = true; };
++++++        mediaElement.oncanplay = () => { locked = true; };
+++++ 
+++++         mediaElement.onerror = () => {
+++++-            if (locked) return; // ignore errors after lock
+++++-
++++++            if (locked) return;
+++++             attempt++;
+++++             if (attempt < retries) {
+++++                 setTimeout(load, 4000 * attempt);
+++++@@ -275,6 +275,9 @@ function playbackIntervention(event) {
+++++     const target = event.target;
+++++     const other = target === videoElement ? audioElement : videoElement;
+++++ 
++++++    // Prevent race while media is buffering or not ready
++++++    if (target.readyState < 2) return;
++++++
+++++     // Only sync audio for non-SB manual seeks
+++++     if (!sponsorSkipInProgress && audioElement.src && !ignoreNext[event.type]--) {
+++++         if (event.type === "seeked") {
+++++@@ -288,7 +291,9 @@ function playbackIntervention(event) {
+++++                 }
+++++             }, 100);
+++++         } else if (event.type === "play") {
+++++-            playManagers[other.tagName.toLowerCase()].play();
++++++            if (other.readyState >= 2) {
++++++                playManagers[other.tagName.toLowerCase()].play();
++++++            }
+++++         } else if (event.type === "pause") {
+++++             other.pause();
+++++         } else if (event.type === "ratechange") {
+++++@@ -368,11 +373,13 @@ function relativeSeek(seconds) {
+++++ }
+++++ 
+++++ async function playVideo() {
+++++-    if (!userInteracted) return; //  prevent auto play before click/gesture
++++++    if (!userInteracted) return;
+++++     if (!videoElement.paused) return;
+++++ 
+++++     audioElement.currentTime = videoElement.currentTime;
+++++-    ignoreNext.play++;
++++++
++++++    // stop the "play/pause fight" loop
++++++    ignoreNext.play = 2;
+++++ 
+++++     try {
+++++         if (audioContext.state === 'suspended') {
+++++@@ -380,8 +387,13 @@ async function playVideo() {
+++++         }
+++++ 
+++++         await videoElement.play();
++++++
+++++         if (playManagers.audio.isActive() && audioElement.src) {
+++++-            await audioElement.play();
++++++            try {
++++++                await audioElement.play();
++++++            } catch (e) {
++++++                console.warn("Audio blocked until user gesture:", e);
++++++            }
+++++         }
+++++     } catch (e) {
+++++         console.error("Video play failed", e);
+++++@@ -404,8 +416,9 @@ function toggleFullScreen() {
+++++     }
+++++ }
+++++ 
+++++-//  Critical: Track interaction and refocus
++++++//  Critical: Track interaction and refocus
+++++ videoElement.addEventListener("pointerdown", () => {
++++++    userInteracted = true
+++++     videoElement.focus();
+++++ });
+++++ 
+++++@@ -416,7 +429,7 @@ videoElement.addEventListener("click", (event) => {
+++++     videoElement.focus();
+++++ });
+++++ 
+++++-//  Capture spacebar early and forcefully
++++++//  Capture spacebar early and forcefully
+++++ const keyActions = new Map([
+++++     ["j", () => relativeSeek(-10)],
+++++     ["n", () => relativeSeek(-10)],
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0004-fix-more-pre-playback-race-conditions.patch b/patches/0004-fix-more-pre-playback-race-conditions.patch
++++new file mode 100644
++++index 0000000..a1389a2
++++--- /dev/null
+++++++ b/patches/0004-fix-more-pre-playback-race-conditions.patch
++++@@ -0,0 +1,33 @@
+++++From 6fa42c7c1d1c89d17e67bc7825ea736dcc85a730 Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Sun, 26 Oct 2025 11:41:00 +0300
+++++Subject: [PATCH 04/31] fix more pre-playback race conditions
+++++
+++++---
+++++ html/static/js/player.js | 3 ++-
+++++ 1 file changed, 2 insertions(+), 1 deletion(-)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index b6efd17..8446b1d 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -93,7 +93,7 @@ function loadMediaWithRetry(mediaElement, url, retries = 6) {
+++++     let reloading = false; // prevent rapid reload loops
+++++ 
+++++     const load = () => {
+++++-        if (locked || reloading) return;
++++++        if (locked && reloading) return;
+++++         reloading = true;
+++++ 
+++++         // prevent immediate consecutive reloads
+++++@@ -109,6 +109,7 @@ function loadMediaWithRetry(mediaElement, url, retries = 6) {
+++++         mediaElement.oncanplay = () => { locked = true; };
+++++ 
+++++         mediaElement.onerror = () => {
++++++            reloading = false;
+++++             if (locked) return;
+++++             attempt++;
+++++             if (attempt < retries) {
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0005-replace-b720p-with-just-720p.patch b/patches/0005-replace-b720p-with-just-720p.patch
++++new file mode 100644
++++index 0000000..ba9784f
++++--- /dev/null
+++++++ b/patches/0005-replace-b720p-with-just-720p.patch
++++@@ -0,0 +1,26 @@
+++++From 13716da489f4faf13edca5c45614904a9cb5e1a8 Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Sun, 26 Oct 2025 11:56:48 +0300
+++++Subject: [PATCH 05/31] replace b720p with just 720p
+++++
+++++---
+++++ pug/settings.pug | 3 +--
+++++ 1 file changed, 1 insertion(+), 2 deletions(-)
+++++
+++++diff --git a/pug/settings.pug b/pug/settings.pug
+++++index d56de25..30f1157 100644
+++++--- a/pug/settings.pug
++++++++ b/pug/settings.pug
+++++@@ -71,8 +71,7 @@ block content
+++++           label: "Preferred qualities",
+++++           description: "All qualities are available on the watch page. This defines their sort order.",
+++++           options: [
+++++-            {value: "1", text: "b720p"},
+++++-            {value: "0", text: "720p"},
++++++            {value: "1", text: "720p"},
+++++             {value: "4", text: "360p"},
+++++             {value: "5", text: "Best possible"},
+++++             {value: "2", text: "Best <=1080p"},
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0006-fix-timestamp-updating-only-on-refresh-after-page-lo.patch b/patches/0006-fix-timestamp-updating-only-on-refresh-after-page-lo.patch
++++new file mode 100644
++++index 0000000..e205621
++++--- /dev/null
+++++++ b/patches/0006-fix-timestamp-updating-only-on-refresh-after-page-lo.patch
++++@@ -0,0 +1,32 @@
+++++From e3d44ab9f6419939c5728829ba91d19dd7753fda Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Thu, 30 Oct 2025 18:31:35 +0300
+++++Subject: [PATCH 06/31] fix timestamp updating only on refresh after page
+++++ load/chapter click
+++++
+++++---
+++++ html/static/js/player.js | 8 ++++++++
+++++ 1 file changed, 8 insertions(+)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index 8446b1d..2f14e49 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -25,6 +25,14 @@ const audioFormats = [];
+++++     }
+++++ });
+++++ 
++++++// Update src from initial url page load
++++++try {
++++++    const src = videoElement.querySelector('source')?.src
++++++    const itag = videoElement.dataset.itag
++++++    const vf = itag && videoFormats.get(itag)
++++++    if (vf && src) vf.url = src
++++++} catch {}
++++++
+++++ function getBestAudioFormat() {
+++++     function parseXtags(url) {
+++++         const urlParams = new URLSearchParams(url.split('?')[1] ?? '');
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0007-smoothen-out-issues-caused-by-audio-load-lag.patch b/patches/0007-smoothen-out-issues-caused-by-audio-load-lag.patch
++++new file mode 100644
++++index 0000000..9faa0cb
++++--- /dev/null
+++++++ b/patches/0007-smoothen-out-issues-caused-by-audio-load-lag.patch
++++@@ -0,0 +1,127 @@
+++++From a97ef86f81b7a01fb1780d034a01552ef7dadcd4 Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Mon, 17 Nov 2025 17:31:18 +0300
+++++Subject: [PATCH 07/31] smoothen out issues caused by audio load lag
+++++
+++++---
+++++ html/static/js/player.js | 37 +++++++++++++++++++++----------------
+++++ 1 file changed, 21 insertions(+), 16 deletions(-)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index 2f14e49..b4e77c3 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -98,16 +98,14 @@ function isValidUrl(string) {
+++++ function loadMediaWithRetry(mediaElement, url, retries = 6) {
+++++     let attempt = 0;
+++++     let locked = false;
+++++-    let reloading = false; // prevent rapid reload loops
++++++    let reloading = false;
+++++ 
+++++     const load = () => {
+++++         if (locked && reloading) return;
+++++         reloading = true;
+++++ 
+++++-        // prevent immediate consecutive reloads
+++++         setTimeout(() => { reloading = false; }, 3000);
+++++ 
+++++-        // if element already has usable buffered data, skip reload
+++++         if (mediaElement.readyState >= 3 && !mediaElement.error) return;
+++++ 
+++++         mediaElement.src = url;
+++++@@ -120,6 +118,7 @@ function loadMediaWithRetry(mediaElement, url, retries = 6) {
+++++             reloading = false;
+++++             if (locked) return;
+++++             attempt++;
++++++            console.error("Audio load failed:", url);
+++++             if (attempt < retries) {
+++++                 setTimeout(load, 4000 * attempt);
+++++             } else {
+++++@@ -128,6 +127,7 @@ function loadMediaWithRetry(mediaElement, url, retries = 6) {
+++++         };
+++++     };
+++++ 
++++++    // Start immediately; your play logic will guard actual playback
+++++     load();
+++++ }
+++++ 
+++++@@ -249,6 +249,13 @@ const ignoreNext = { play: 0 };
+++++ 
+++++ function startSyncCheck() {
+++++     if (syncCheckInterval) clearInterval(syncCheckInterval);
++++++
++++++    // Only start syncing if audio is ready or theres no separate audio
++++++    if (formatLoader.npa && audioElement.readyState < 2) {
++++++        audioElement.addEventListener('canplaythrough', startSyncCheck, { once: true });
++++++        return;
++++++    }
++++++
+++++     syncCheckInterval = setInterval(() => {
+++++         if (!videoElement.paused && !audioElement.paused) {
+++++             const drift = Math.abs(videoElement.currentTime - audioElement.currentTime);
+++++@@ -386,29 +393,27 @@ async function playVideo() {
+++++     if (!videoElement.paused) return;
+++++ 
+++++     audioElement.currentTime = videoElement.currentTime;
+++++-
+++++-    // stop the "play/pause fight" loop
+++++     ignoreNext.play = 2;
+++++ 
+++++     try {
+++++-        if (audioContext.state === 'suspended') {
+++++-            await audioContext.resume();
+++++-        }
+++++-
++++++        if (audioContext.state === 'suspended') await audioContext.resume();
+++++         await videoElement.play();
+++++ 
+++++         if (playManagers.audio.isActive() && audioElement.src) {
+++++-            try {
++++++            if (audioElement.readyState >= 2) {
+++++                 await audioElement.play();
+++++-            } catch (e) {
+++++-                console.warn("Audio blocked until user gesture:", e);
++++++            } else {
++++++                audioElement.addEventListener('canplaythrough', async () => {
++++++                    if (!audioElement.paused) await audioElement.play();
++++++                }, { once: true });
+++++             }
+++++         }
+++++     } catch (e) {
+++++-        console.error("Video play failed", e);
++++++        console.error("Playback failed:", e);
+++++     }
+++++ }
+++++ 
++++++
+++++ function togglePlaying() {
+++++     if (videoElement.paused) {
+++++         playVideo();
+++++@@ -425,7 +430,7 @@ function toggleFullScreen() {
+++++     }
+++++ }
+++++ 
+++++-//  Critical: Track interaction and refocus
++++++//  Critical: Track interaction and refocus
+++++ videoElement.addEventListener("pointerdown", () => {
+++++     userInteracted = true
+++++     videoElement.focus();
+++++@@ -438,7 +443,7 @@ videoElement.addEventListener("click", (event) => {
+++++     videoElement.focus();
+++++ });
+++++ 
+++++-//  Capture spacebar early and forcefully
++++++//  Capture spacebar early and forcefully
+++++ const keyActions = new Map([
+++++     ["j", () => relativeSeek(-10)],
+++++     ["n", () => relativeSeek(-10)],
+++++@@ -529,4 +534,4 @@ document.addEventListener('click', (event) => {
+++++             window.history.replaceState(null, '', timestampEl.href);
+++++         }
+++++     }
+++++-});
+++++\ No newline at end of file
++++++});
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0008-remember-selected-quality-within-session.patch b/patches/0008-remember-selected-quality-within-session.patch
++++new file mode 100644
++++index 0000000..bdcb307
++++--- /dev/null
+++++++ b/patches/0008-remember-selected-quality-within-session.patch
++++@@ -0,0 +1,156 @@
+++++From 86b26d57166cf9d7f2d22747e52837781f58e1e8 Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Mon, 17 Nov 2025 19:48:03 +0300
+++++Subject: [PATCH 08/31] remember selected quality within session
+++++
+++++---
+++++ html/static/js/player.js | 101 ++++++++++++++++++++++++++++++++-------
+++++ 1 file changed, 84 insertions(+), 17 deletions(-)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index b4e77c3..839e1c5 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -167,11 +167,10 @@ class FormatLoader {
+++++         this.npa = null;
+++++     }
+++++ 
+++++-    play(itag) {
++++++    play(itag, isQualitySwitch = false) {
+++++         this.npv = videoFormats.get(itag);
+++++         this.npa = null;
+++++ 
+++++-        // Only attach separate audio if the stream has no audio codec
+++++         const hasAudio = this.npv.type && (this.npv.type.includes("mp4a") || this.npv.type.includes("audio"));
+++++         if (!hasAudio) {
+++++             const bestAudio = getBestAudioFormat();
+++++@@ -180,29 +179,75 @@ class FormatLoader {
+++++             }
+++++         }
+++++ 
+++++-        this.update();
++++++        this.update(isQualitySwitch);
+++++     }
+++++ 
+++++-    update() {
++++++
++++++    update(isQualitySwitch = false) {
+++++         cleanupSync();
+++++-        const lastTime = videoElement.currentTime;
+++++ 
+++++-        loadMediaWithRetry(videoElement, this.npv.url);
+++++-        videoElement.currentTime = lastTime;
++++++        // Use currentTime only if >0, otherwise let URL seek apply
++++++        const lastTime = isQualitySwitch ? videoElement.currentTime : null;
++++++
++++++        if (!this.npv.url) {
++++++            console.error("No URL for video format! Cannot load.");
++++++            return;
++++++        }
++++++
++++++        if (isQualitySwitch) {
++++++
++++++            videoElement.pause();
++++++            stopSyncCheck();
++++++
++++++            let videoReady = false;
++++++            let audioReady = false;
++++++
++++++            const tryResume = () => {
++++++                if (videoReady && (audioReady || !this.npa)) {
++++++                    if (lastTime !== null) videoElement.currentTime = lastTime;
++++++                    videoElement.play().catch(() => {});
++++++
++++++                    if (this.npa) {
++++++                        if (lastTime !== null) audioElement.currentTime = lastTime;
++++++                        audioElement.play().catch(() => {});
++++++                    }
++++++
++++++                    startSyncCheck();
++++++                }
++++++            };
++++++
++++++            videoElement.src = this.npv.url;
++++++            videoElement.load();
++++++            videoElement.addEventListener('canplaythrough', () => {
++++++                videoReady = true;
++++++                tryResume();
++++++            }, { once: true });
++++++
++++++            if (this.npa) {
++++++                audioElement.src = this.npa.url;
++++++                audioElement.load();
++++++                audioElement.addEventListener('canplaythrough', () => {
++++++                    audioReady = true;
++++++                    tryResume();
++++++                }, { once: true });
++++++            } else {
++++++                audioElement.pause();
++++++                audioElement.removeAttribute("src");
++++++                audioReady = true;
++++++            }
+++++ 
+++++-        if (this.npa) {
+++++-            audioElement.pause();
+++++-            audioElement.src = "";
+++++-            loadMediaWithRetry(audioElement, this.npa.url);
+++++-            audioElement.currentTime = lastTime;
+++++         } else {
+++++-            audioElement.pause();
+++++-            audioElement.removeAttribute("src");
++++++            loadMediaWithRetry(videoElement, this.npv.url);
++++++
++++++            if (this.npa) loadMediaWithRetry(audioElement, this.npa.url);
++++++            else {
++++++                audioElement.pause();
++++++                audioElement.removeAttribute("src");
++++++            }
+++++         }
+++++     }
+++++ }
+++++ 
+++++-
+++++ const formatLoader = new FormatLoader();
+++++ 
+++++ class PlayManager {
+++++@@ -232,13 +277,35 @@ const playManagers = {
+++++ class QualitySelect extends ElemJS {
+++++     constructor() {
+++++         super(q("#quality-select"));
++++++        const saved = localStorage.getItem("lastQuality");
++++++        if (saved) this.element.value = saved;
+++++         this.on("input", this.setFormat.bind(this));
+++++-        this.setFormat();
++++++        this.initialized = false;
++++++
++++++        // Defer initial format activation until the browser applies &t=
++++++        requestAnimationFrame(() => {
++++++            this.initialized = true;
++++++
++++++            if (saved) {
++++++                if (videoElement.readyState >= 1) {
++++++                    formatLoader.play(saved, true);
++++++                } else {
++++++                    videoElement.addEventListener("loadedmetadata", () => {
++++++                        formatLoader.play(saved, true);
++++++                    }, { once: true });
++++++                }
++++++            }
++++++        });
+++++     }
+++++ 
++++++
+++++     setFormat() {
++++++        if (!this.initialized) return;
++++++
+++++         const itag = this.element.value;
+++++-        formatLoader.play(itag);
++++++        localStorage.setItem("lastQuality", itag);
++++++
++++++        formatLoader.play(itag, true);
+++++         videoElement.focus();
+++++     }
+++++ }
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0009-fix-logging-spam.patch b/patches/0009-fix-logging-spam.patch
++++new file mode 100644
++++index 0000000..ff7aa83
++++--- /dev/null
+++++++ b/patches/0009-fix-logging-spam.patch
++++@@ -0,0 +1,24 @@
+++++From b399755f9b02bd4f6158593c7b3ea5b07a728bda Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Mon, 17 Nov 2025 19:59:17 +0300
+++++Subject: [PATCH 09/31] fix logging spam
+++++
+++++---
+++++ html/static/js/chapter-highlight.js | 1 +
+++++ 1 file changed, 1 insertion(+)
+++++
+++++diff --git a/html/static/js/chapter-highlight.js b/html/static/js/chapter-highlight.js
+++++index d87ecd3..194cf81 100644
+++++--- a/html/static/js/chapter-highlight.js
++++++++ b/html/static/js/chapter-highlight.js
+++++@@ -24,6 +24,7 @@ function getCurrentChapter(time) {
+++++ }
+++++ 
+++++ function updateHighlight() {
++++++	if (!video) return
+++++ 	const currentChapter = getCurrentChapter(video.currentTime)
+++++ 	if (currentChapter !== lastChapter) {
+++++ 		if (lastChapter) lastChapter.link.removeClass("timestamp--active")
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0010-fix-audio-stream-selection-issues.patch b/patches/0010-fix-audio-stream-selection-issues.patch
++++new file mode 100644
++++index 0000000..6c552cd
++++--- /dev/null
+++++++ b/patches/0010-fix-audio-stream-selection-issues.patch
++++@@ -0,0 +1,63 @@
+++++From b35625238af17f71cf0d5a694dcfd68dc210e985 Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Mon, 17 Nov 2025 21:28:33 +0300
+++++Subject: [PATCH 10/31] fix audio stream selection issues
+++++
+++++---
+++++ html/static/js/player.js | 16 +++++++++++++---
+++++ 1 file changed, 13 insertions(+), 3 deletions(-)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index 839e1c5..2ebfc43 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -165,6 +165,18 @@ class FormatLoader {
+++++     constructor() {
+++++         this.npv = videoFormats.get(videoElement.getAttribute("data-itag"));
+++++         this.npa = null;
++++++
++++++        // --- FIX: attach best audio on initial load if video has no audio ---
++++++        const hasAudio = this.npv.type && (this.npv.type.includes("mp4a") || this.npv.type.includes("audio"));
++++++        if (!hasAudio) {
++++++            const bestAudio = getBestAudioFormat();
++++++            if (bestAudio) {
++++++                this.npa = bestAudio;
++++++            }
++++++        }
++++++
++++++        // Load media immediately
++++++        requestAnimationFrame(() => this.update());
+++++     }
+++++ 
+++++     play(itag, isQualitySwitch = false) {
+++++@@ -182,11 +194,9 @@ class FormatLoader {
+++++         this.update(isQualitySwitch);
+++++     }
+++++ 
+++++-
+++++     update(isQualitySwitch = false) {
+++++         cleanupSync();
+++++ 
+++++-        // Use currentTime only if >0, otherwise let URL seek apply
+++++         const lastTime = isQualitySwitch ? videoElement.currentTime : null;
+++++ 
+++++         if (!this.npv.url) {
+++++@@ -195,7 +205,6 @@ class FormatLoader {
+++++         }
+++++ 
+++++         if (isQualitySwitch) {
+++++-
+++++             videoElement.pause();
+++++             stopSyncCheck();
+++++ 
+++++@@ -248,6 +257,7 @@ class FormatLoader {
+++++     }
+++++ }
+++++ 
++++++
+++++ const formatLoader = new FormatLoader();
+++++ 
+++++ class PlayManager {
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0011-remember-quality-consistently-even-after-url-refresh.patch b/patches/0011-remember-quality-consistently-even-after-url-refresh.patch
++++new file mode 100644
++++index 0000000..3ec5f84
++++--- /dev/null
+++++++ b/patches/0011-remember-quality-consistently-even-after-url-refresh.patch
++++@@ -0,0 +1,53 @@
+++++From 26ad8852d9c9ea500f60aefac43ddc922b4af525 Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Mon, 17 Nov 2025 21:38:32 +0300
+++++Subject: [PATCH 11/31] remember quality consistently even after url refresh
+++++
+++++---
+++++ html/static/js/player.js | 17 ++++++++++-------
+++++ 1 file changed, 10 insertions(+), 7 deletions(-)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index 2ebfc43..904900f 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -287,16 +287,16 @@ const playManagers = {
+++++ class QualitySelect extends ElemJS {
+++++     constructor() {
+++++         super(q("#quality-select"));
+++++-        const saved = localStorage.getItem("lastQuality");
+++++-        if (saved) this.element.value = saved;
+++++-        this.on("input", this.setFormat.bind(this));
+++++         this.initialized = false;
+++++ 
+++++-        // Defer initial format activation until the browser applies &t=
++++++        // Defer until DOM & videoFormats ready
+++++         requestAnimationFrame(() => {
+++++-            this.initialized = true;
++++++            const saved = localStorage.getItem("lastQuality");
++++++
++++++            // Only set value if the option exists
++++++            if (saved && this.element.querySelector(`option[value="${saved}"]`)) {
++++++                this.element.value = saved;
+++++ 
+++++-            if (saved) {
+++++                 if (videoElement.readyState >= 1) {
+++++                     formatLoader.play(saved, true);
+++++                 } else {
+++++@@ -305,9 +305,12 @@ class QualitySelect extends ElemJS {
+++++                     }, { once: true });
+++++                 }
+++++             }
++++++
++++++            this.initialized = true;
+++++         });
+++++-    }
+++++ 
++++++        this.on("input", this.setFormat.bind(this));
++++++    }
+++++ 
+++++     setFormat() {
+++++         if (!this.initialized) return;
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0012-tighten-video-audio-sync.patch b/patches/0012-tighten-video-audio-sync.patch
++++new file mode 100644
++++index 0000000..4cc849e
++++--- /dev/null
+++++++ b/patches/0012-tighten-video-audio-sync.patch
++++@@ -0,0 +1,46 @@
+++++From 0caac7349908b3c26b699eaafc085676cafabe7e Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Mon, 17 Nov 2025 21:47:20 +0300
+++++Subject: [PATCH 12/31] tighten video+audio sync
+++++
+++++---
+++++ html/static/js/player.js | 14 ++++++++++----
+++++ 1 file changed, 10 insertions(+), 4 deletions(-)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index 904900f..dbd8dba 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -472,19 +472,25 @@ async function playVideo() {
+++++     if (!userInteracted) return;
+++++     if (!videoElement.paused) return;
+++++ 
+++++-    audioElement.currentTime = videoElement.currentTime;
++++++    const targetTime = videoElement.currentTime;
++++++    audioElement.currentTime = targetTime;
+++++     ignoreNext.play = 2;
+++++ 
+++++     try {
+++++         if (audioContext.state === 'suspended') await audioContext.resume();
+++++-        await videoElement.play();
+++++ 
+++++-        if (playManagers.audio.isActive() && audioElement.src) {
++++++        // Only play video immediately if no separate audio, otherwise wait for audio
++++++        if (!formatLoader.npa) {
++++++            await videoElement.play();
++++++        } else {
++++++            // Wait until audio can play
+++++             if (audioElement.readyState >= 2) {
+++++                 await audioElement.play();
++++++                await videoElement.play();
+++++             } else {
+++++                 audioElement.addEventListener('canplaythrough', async () => {
+++++-                    if (!audioElement.paused) await audioElement.play();
++++++                    await audioElement.play();
++++++                    await videoElement.play();
+++++                 }, { once: true });
+++++             }
+++++         }
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0013-more-bug-buffering-fixes.patch b/patches/0013-more-bug-buffering-fixes.patch
++++new file mode 100644
++++index 0000000..6e3c974
++++--- /dev/null
+++++++ b/patches/0013-more-bug-buffering-fixes.patch
++++@@ -0,0 +1,52 @@
+++++From 6778843e215a0130ebd0aae312d2756e6036ff15 Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Mon, 24 Nov 2025 14:48:13 +0300
+++++Subject: [PATCH 13/31] more bug buffering fixes
+++++
+++++---
+++++ html/static/js/player.js | 30 ++++++++++++++++++++----------
+++++ 1 file changed, 20 insertions(+), 10 deletions(-)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index dbd8dba..e370be0 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -610,14 +610,24 @@ audioElement.setAttribute('preload', 'metadata');
+++++ 
+++++ new SubscribeButton(q("#subscribe"));
+++++ 
++++++let userSeeking = false;
+++++ document.addEventListener('click', (event) => {
+++++-    const timestampEl = event.target.closest('[data-clickable-timestamp]');
+++++-    if (timestampEl) {
+++++-        event.preventDefault();
+++++-        const time = parseFloat(timestampEl.getAttribute('data-clickable-timestamp'));
+++++-        if (!isNaN(time)) {
+++++-            videoElement.currentTime = time;
+++++-            window.history.replaceState(null, '', timestampEl.href);
+++++-        }
+++++-    }
+++++-});
++++++  const timestampEl = event.target.closest('[data-clickable-timestamp]');
++++++  if (!timestampEl) return;
++++++
++++++  event.preventDefault();
++++++  const time = parseFloat(timestampEl.getAttribute('data-clickable-timestamp'));
++++++  if (isNaN(time)) return;
++++++
++++++  // This single line stops the play/pause buffering loop
++++++  userSeeking = true;
++++++
++++++  videoElement.currentTime = time;
++++++  if (formatLoader.npa) audioElement.currentTime = time;
++++++
++++++  window.history.replaceState(null, '', timestampEl.href);
++++++
++++++  // Clear flag after seek settles
++++++  videoElement.addEventListener('seeked', () =>
++++++    setTimeout(() => userSeeking = false, 300), { once: true });
++++++});
+++++\ No newline at end of file
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0014-preload-network-connections.patch b/patches/0014-preload-network-connections.patch
++++new file mode 100644
++++index 0000000..704fec2
++++--- /dev/null
+++++++ b/patches/0014-preload-network-connections.patch
++++@@ -0,0 +1,85 @@
+++++From 85c497a0676abf4c2dad266046206f8636956fb6 Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Tue, 25 Nov 2025 23:28:19 +0300
+++++Subject: [PATCH 14/31] preload network connections
+++++
+++++---
+++++ html/static/js/player.js | 34 ++++++++++++++++++++--------------
+++++ 1 file changed, 20 insertions(+), 14 deletions(-)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index e370be0..69e80e8 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -2,6 +2,7 @@ import { q, qa, ElemJS } from "/static/js/elemjs/elemjs.js";
+++++ import { SubscribeButton } from "/static/js/modules/SubscribeButton.js";
+++++ 
+++++ const videoElement = q("#video");
++++++videoElement.setAttribute("fetchpriority", "high");
+++++ const audioElement = q("#audio");
+++++ // Buffer audio aggressively
+++++ audioElement.preload = "auto";
+++++@@ -95,18 +96,23 @@ function isValidUrl(string) {
+++++     }
+++++ }
+++++ 
++++++function warmup(url) {
++++++    try {
++++++        const origin = new URL(url).origin;
++++++        const link = document.createElement("link");
++++++        link.rel = "preconnect";
++++++        link.href = origin;
++++++        document.head.appendChild(link);
++++++    } catch {}
++++++}
++++++
+++++ function loadMediaWithRetry(mediaElement, url, retries = 6) {
+++++     let attempt = 0;
+++++     let locked = false;
+++++-    let reloading = false;
+++++-
+++++-    const load = () => {
+++++-        if (locked && reloading) return;
+++++-        reloading = true;
+++++-
+++++-        setTimeout(() => { reloading = false; }, 3000);
+++++ 
+++++-        if (mediaElement.readyState >= 3 && !mediaElement.error) return;
++++++    function tryLoad() {
++++++        // warm up connection BEFORE requesting the media
++++++        warmup(url);
+++++ 
+++++         mediaElement.src = url;
+++++         mediaElement.load();
+++++@@ -115,22 +121,22 @@ function loadMediaWithRetry(mediaElement, url, retries = 6) {
+++++         mediaElement.oncanplay = () => { locked = true; };
+++++ 
+++++         mediaElement.onerror = () => {
+++++-            reloading = false;
+++++             if (locked) return;
+++++             attempt++;
+++++-            console.error("Audio load failed:", url);
++++++            console.error("Media load failed:", url);
++++++
+++++             if (attempt < retries) {
+++++-                setTimeout(load, 4000 * attempt);
++++++                setTimeout(tryLoad, 1000 * attempt); // gradual backoff, same logic, faster start
+++++             } else {
+++++                 console.error("Failed to load media after", retries, "attempts.");
+++++             }
+++++         };
+++++-    };
++++++    }
+++++ 
+++++-    // Start immediately; your play logic will guard actual playback
+++++-    load();
++++++    tryLoad();
+++++ }
+++++ 
++++++
+++++ let pipReady = false;
+++++ 
+++++ document.addEventListener("visibilitychange", async () => {
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0015-fix-seek-buffer-flickering.patch b/patches/0015-fix-seek-buffer-flickering.patch
++++new file mode 100644
++++index 0000000..3abaca0
++++--- /dev/null
+++++++ b/patches/0015-fix-seek-buffer-flickering.patch
++++@@ -0,0 +1,59 @@
+++++From a46d7e803d9ec07ed3544a59307a4b008759e0b3 Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Sat, 29 Nov 2025 00:11:40 +0300
+++++Subject: [PATCH 15/31] fix seek buffer flickering
+++++
+++++---
+++++ html/static/js/player.js | 36 ++++++++++++++++++++++++++++++++++++
+++++ 1 file changed, 36 insertions(+)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index 69e80e8..d172231 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -455,6 +455,42 @@ videoElement.addEventListener("playing", () => {
+++++     }
+++++ });
+++++ 
++++++// --- Robust smooth seek for separate audio/video ---
++++++let freezePlayback = false
++++++let shouldResume = false
++++++
++++++videoElement.addEventListener("seeking", () => {
++++++    freezePlayback = true
++++++    if (!videoElement.paused || (formatLoader.npa && !audioElement.paused)) {
++++++        shouldResume = true
++++++        videoElement.pause()
++++++        if (formatLoader.npa) audioElement.pause()
++++++    }
++++++})
++++++
++++++function resumeWhenBuffered() {
++++++    if (!freezePlayback || !shouldResume) return
++++++
++++++    const videoReady = videoElement.readyState >= 3
++++++    const audioReady = !formatLoader.npa || audioElement.readyState >= 3
++++++
++++++    if (videoReady && audioReady) {
++++++        freezePlayback = false
++++++        shouldResume = false
++++++        const t = videoElement.currentTime
++++++        if (formatLoader.npa) audioElement.currentTime = t
++++++        videoElement.play().catch(()=>{})
++++++        if (formatLoader.npa) audioElement.play().catch(()=>{})
++++++    } else {
++++++        // Retry shortly until both ready
++++++        requestAnimationFrame(resumeWhenBuffered)
++++++    }
++++++}
++++++
++++++videoElement.addEventListener("seeking", () => {
++++++    requestAnimationFrame(resumeWhenBuffered)
++++++})
++++++
+++++ 
+++++ const videoObserver = new IntersectionObserver((entries) => {
+++++     entries.forEach(entry => {
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0016-buffer-media-syncing-fixes.patch b/patches/0016-buffer-media-syncing-fixes.patch
++++new file mode 100644
++++index 0000000..380eecc
++++--- /dev/null
+++++++ b/patches/0016-buffer-media-syncing-fixes.patch
++++@@ -0,0 +1,50 @@
+++++From 1341b5ce7ffeeff4f67b3b7888fbd6e5229e936a Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Mon, 29 Dec 2025 21:29:54 +0300
+++++Subject: [PATCH 16/31] buffer + media syncing fixes
+++++
+++++---
+++++ html/static/js/player.js | 12 ++++++++++--
+++++ 1 file changed, 10 insertions(+), 2 deletions(-)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index d172231..8cc551b 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -2,16 +2,17 @@ import { q, qa, ElemJS } from "/static/js/elemjs/elemjs.js";
+++++ import { SubscribeButton } from "/static/js/modules/SubscribeButton.js";
+++++ 
+++++ const videoElement = q("#video");
+++++-videoElement.setAttribute("fetchpriority", "high");
++++++videoElement.setAttribute("fetchpriority", "low");
+++++ const audioElement = q("#audio");
+++++ // Buffer audio aggressively
++++++audioElement.setAttribute("fetchpriority", "high");
+++++ audioElement.preload = "auto";
+++++ 
+++++ // Make video focusable
+++++ videoElement.setAttribute("tabindex", "0");
+++++ 
+++++ let userInteracted = false;
+++++-document.addEventListener("click", () => { userInteracted = true; }, { once: true });
++++++document.addEventListener("click", () => { userInteracted = true; alignStreams(); }, { once: true });
+++++ 
+++++ let syncCheckInterval = null;
+++++ const videoFormats = new Map();
+++++@@ -136,6 +137,13 @@ function loadMediaWithRetry(mediaElement, url, retries = 6) {
+++++     tryLoad();
+++++ }
+++++ 
++++++function alignStreams() {
++++++    if (!audioElement.src || !videoElement.src) return;
++++++    const t = Math.max(audioElement.currentTime || 0, videoElement.currentTime || 0);
++++++    audioElement.currentTime = t;
++++++    videoElement.currentTime = t;
++++++}
++++++
+++++ 
+++++ let pipReady = false;
+++++ 
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0017-more-warmup-improvements.patch b/patches/0017-more-warmup-improvements.patch
++++new file mode 100644
++++index 0000000..193192e
++++--- /dev/null
+++++++ b/patches/0017-more-warmup-improvements.patch
++++@@ -0,0 +1,58 @@
+++++From 70a5385a0e23464aa343534ac1cd7022daa0d6c9 Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Fri, 2 Jan 2026 17:31:22 +0300
+++++Subject: [PATCH 17/31] more warmup improvements
+++++
+++++---
+++++ html/static/js/player.js | 25 +++++++++++++++++++++----
+++++ 1 file changed, 21 insertions(+), 4 deletions(-)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index 8cc551b..6430f7d 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -27,6 +27,10 @@ const audioFormats = [];
+++++     }
+++++ });
+++++ 
++++++// --- pre-warm all known origins ---
++++++videoFormats.forEach(vf => warmup(vf.url));
++++++audioFormats.forEach(af => warmup(af.url));
++++++
+++++ // Update src from initial url page load
+++++ try {
+++++     const src = videoElement.querySelector('source')?.src
+++++@@ -97,13 +101,26 @@ function isValidUrl(string) {
+++++     }
+++++ }
+++++ 
++++++const warmedOrigins = new Set();
++++++
+++++ function warmup(url) {
+++++     try {
+++++         const origin = new URL(url).origin;
+++++-        const link = document.createElement("link");
+++++-        link.rel = "preconnect";
+++++-        link.href = origin;
+++++-        document.head.appendChild(link);
++++++        if (warmedOrigins.has(origin)) return; // already done
++++++        warmedOrigins.add(origin);
++++++
++++++        // Preconnect: TCP + TLS
++++++        const preconnectLink = document.createElement("link");
++++++        preconnectLink.rel = "preconnect";
++++++        preconnectLink.href = origin;
++++++        document.head.appendChild(preconnectLink);
++++++
++++++        // DNS prefetch
++++++        const dnsLink = document.createElement("link");
++++++        dnsLink.rel = "dns-prefetch";
++++++        dnsLink.href = origin;
++++++        document.head.appendChild(dnsLink);
++++++
+++++     } catch {}
+++++ }
+++++ 
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0018-fix-userInteracted.patch b/patches/0018-fix-userInteracted.patch
++++new file mode 100644
++++index 0000000..c853fc0
++++--- /dev/null
+++++++ b/patches/0018-fix-userInteracted.patch
++++@@ -0,0 +1,36 @@
+++++From d883a2829d4dd0fcb1c3b3937463641bc54fe95f Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Sat, 10 Jan 2026 13:32:39 +0300
+++++Subject: [PATCH 18/31] fix userInteracted
+++++
+++++---
+++++ html/static/js/player.js | 3 +++
+++++ 1 file changed, 3 insertions(+)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index 6430f7d..162746a 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -226,6 +226,7 @@ class FormatLoader {
+++++     }
+++++ 
+++++     update(isQualitySwitch = false) {
++++++        if (!userInteracted) return;
+++++         cleanupSync();
+++++ 
+++++         const lastTime = isQualitySwitch ? videoElement.currentTime : null;
+++++@@ -569,9 +570,11 @@ async function playVideo() {
+++++ 
+++++ function togglePlaying() {
+++++     if (videoElement.paused) {
++++++        if (!userInteracted) return;
+++++         playVideo();
+++++     } else {
+++++         videoElement.pause();
++++++        if (formatLoader.npa) audioElement.pause(); // also pause separate audio
+++++     }
+++++ }
+++++ 
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0019-remove-sponsorblock-deadcode.patch b/patches/0019-remove-sponsorblock-deadcode.patch
++++new file mode 100644
++++index 0000000..9067928
++++--- /dev/null
+++++++ b/patches/0019-remove-sponsorblock-deadcode.patch
++++@@ -0,0 +1,41 @@
+++++From d83e89bd2cd64dbfa0f72da818f76030f4fd76af Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Sat, 10 Jan 2026 13:59:57 +0300
+++++Subject: [PATCH 19/31] remove sponsorblock deadcode
+++++
+++++---
+++++ html/static/js/player.js | 11 +----------
+++++ 1 file changed, 1 insertion(+), 10 deletions(-)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index 162746a..8eb73c4 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -390,15 +390,6 @@ function cleanupSync() {
+++++ videoElement.addEventListener("play", startSyncCheck);
+++++ videoElement.addEventListener("pause", stopSyncCheck);
+++++ 
+++++-// --- SponsorBlock skip fix
+++++-let sponsorSkipInProgress = false; // flag to track SB skip
+++++-
+++++-// Wrap SponsorBlock skips by listening for its events
+++++-document.addEventListener("SponsorBlockSkip", () => {
+++++-    sponsorSkipInProgress = true;
+++++-    setTimeout(() => { sponsorSkipInProgress = false; }, 100); // short debounce
+++++-});
+++++-
+++++ function playbackIntervention(event) {
+++++     const target = event.target;
+++++     const other = target === videoElement ? audioElement : videoElement;
+++++@@ -407,7 +398,7 @@ function playbackIntervention(event) {
+++++     if (target.readyState < 2) return;
+++++ 
+++++     // Only sync audio for non-SB manual seeks
+++++-    if (!sponsorSkipInProgress && audioElement.src && !ignoreNext[event.type]--) {
++++++    if (audioElement.src && !ignoreNext[event.type]--) {
+++++         if (event.type === "seeked") {
+++++             const targetTime = target.currentTime;
+++++             other.currentTime = targetTime;
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0020-improve-seeking-audio-lag.patch b/patches/0020-improve-seeking-audio-lag.patch
++++new file mode 100644
++++index 0000000..a02e788
++++--- /dev/null
+++++++ b/patches/0020-improve-seeking-audio-lag.patch
++++@@ -0,0 +1,27 @@
+++++From 694ab576fed958e9c902a0f45490fedb75f9471a Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Wed, 14 Jan 2026 14:23:49 +0300
+++++Subject: [PATCH 20/31] improve seeking audio lag
+++++
+++++---
+++++ html/static/js/player.js | 4 +++-
+++++ 1 file changed, 3 insertions(+), 1 deletion(-)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index 8eb73c4..cf06063 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -524,7 +524,9 @@ const videoObserver = new IntersectionObserver((entries) => {
+++++ videoObserver.observe(videoElement);
+++++ 
+++++ function relativeSeek(seconds) {
+++++-    videoElement.currentTime += seconds;
++++++    const t = videoElement.currentTime + seconds;
++++++    videoElement.currentTime = t;
++++++    if (formatLoader.npa) audioElement.currentTime = t;
+++++ }
+++++ 
+++++ async function playVideo() {
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0021-smoothen-playback-ux.patch b/patches/0021-smoothen-playback-ux.patch
++++new file mode 100644
++++index 0000000..dc4058f
++++--- /dev/null
+++++++ b/patches/0021-smoothen-playback-ux.patch
++++@@ -0,0 +1,96 @@
+++++From be0f5e6a1afa59f2f4223574341eb84e895f5226 Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Wed, 14 Jan 2026 16:58:45 +0300
+++++Subject: [PATCH 21/31] smoothen playback ux
+++++
+++++---
+++++ html/static/js/player.js | 38 ++++++++++++++++++++++++++++++++------
+++++ 1 file changed, 32 insertions(+), 6 deletions(-)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index cf06063..94c18e9 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -246,7 +246,7 @@ class FormatLoader {
+++++             const tryResume = () => {
+++++                 if (videoReady && (audioReady || !this.npa)) {
+++++                     if (lastTime !== null) videoElement.currentTime = lastTime;
+++++-                    videoElement.play().catch(() => {});
++++++                    safeVideoPlay().catch(() => {});
+++++ 
+++++                     if (this.npa) {
+++++                         if (lastTime !== null) audioElement.currentTime = lastTime;
+++++@@ -387,6 +387,32 @@ function cleanupSync() {
+++++     stopSyncCheck();
+++++ }
+++++ 
++++++async function safeVideoPlay() {
++++++    if (!formatLoader.npa) return videoElement.play().catch(()=>{});
++++++
++++++    const tryPlay = async () => {
++++++        const bufferedEnd = audioElement.buffered.length
++++++            ? audioElement.buffered.end(audioElement.buffered.length - 1)
++++++            : 0;
++++++
++++++        if (bufferedEnd >= videoElement.currentTime + 0.25) {
++++++            videoElement.play().catch(()=>{});
++++++        } else {
++++++            // Wait until audio buffers enough
++++++            await new Promise(resolve => {
++++++                const onCanPlay = () => {
++++++                    audioElement.removeEventListener('canplay', onCanPlay);
++++++                    resolve();
++++++                };
++++++                audioElement.addEventListener('canplay', onCanPlay);
++++++            });
++++++            tryPlay();
++++++        }
++++++    };
++++++
++++++    tryPlay();
++++++}
++++++
+++++ videoElement.addEventListener("play", startSyncCheck);
+++++ videoElement.addEventListener("pause", stopSyncCheck);
+++++ 
+++++@@ -496,7 +522,7 @@ function resumeWhenBuffered() {
+++++         shouldResume = false
+++++         const t = videoElement.currentTime
+++++         if (formatLoader.npa) audioElement.currentTime = t
+++++-        videoElement.play().catch(()=>{})
++++++        safeVideoPlay().catch(()=>{})
+++++         if (formatLoader.npa) audioElement.play().catch(()=>{})
+++++     } else {
+++++         // Retry shortly until both ready
+++++@@ -542,16 +568,16 @@ async function playVideo() {
+++++ 
+++++         // Only play video immediately if no separate audio, otherwise wait for audio
+++++         if (!formatLoader.npa) {
+++++-            await videoElement.play();
++++++            await safeVideoPlay();
+++++         } else {
+++++             // Wait until audio can play
+++++             if (audioElement.readyState >= 2) {
+++++                 await audioElement.play();
+++++-                await videoElement.play();
++++++                await safeVideoPlay();
+++++             } else {
+++++                 audioElement.addEventListener('canplaythrough', async () => {
+++++                     await audioElement.play();
+++++-                    await videoElement.play();
++++++                    await safeVideoPlay();
+++++                 }, { once: true });
+++++             }
+++++         }
+++++@@ -623,7 +649,7 @@ document.addEventListener("keydown", async (event) => {
+++++         // Attempt to play video and audio
+++++         try {
+++++             if (videoElement.paused) {
+++++-                await videoElement.play(); // counts as user gesture
++++++                await safeVideoPlay(); // counts as user gesture
+++++                 if (audioElement.src && playManagers.audio.isActive()) {
+++++                     try {
+++++                         await audioElement.play();
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0022-fix-seeking-audio-disappearance.patch b/patches/0022-fix-seeking-audio-disappearance.patch
++++new file mode 100644
++++index 0000000..d870708
++++--- /dev/null
+++++++ b/patches/0022-fix-seeking-audio-disappearance.patch
++++@@ -0,0 +1,30 @@
+++++From 9a4f0a42383aaecc656f3ccb2a5f226dc38be43c Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Thu, 15 Jan 2026 08:28:25 +0300
+++++Subject: [PATCH 22/31] fix seeking audio disappearance
+++++
+++++---
+++++ html/static/js/player.js | 7 +++++++
+++++ 1 file changed, 7 insertions(+)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index 94c18e9..59a8662 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -618,6 +618,13 @@ videoElement.addEventListener("click", (event) => {
+++++     videoElement.focus();
+++++ });
+++++ 
++++++videoElement.addEventListener("seeked", () => {
++++++    if (formatLoader.npa) {
++++++        audioElement.muted = false;
++++++        audioElement.currentTime = videoElement.currentTime;
++++++    }
++++++});
++++++
+++++ //  Capture spacebar early and forcefully
+++++ const keyActions = new Map([
+++++     ["j", () => relativeSeek(-10)],
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0023-Revert-smoothen-playback-ux.patch b/patches/0023-Revert-smoothen-playback-ux.patch
++++new file mode 100644
++++index 0000000..17f68b4
++++--- /dev/null
+++++++ b/patches/0023-Revert-smoothen-playback-ux.patch
++++@@ -0,0 +1,97 @@
+++++From 38fc8f04a6f39315e97e8f7458079f3bb9a3f18a Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Thu, 15 Jan 2026 09:12:42 +0300
+++++Subject: [PATCH 23/31] Revert "smoothen playback ux"
+++++
+++++This reverts commit be0f5e6a1afa59f2f4223574341eb84e895f5226.
+++++---
+++++ html/static/js/player.js | 38 ++++++--------------------------------
+++++ 1 file changed, 6 insertions(+), 32 deletions(-)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index 59a8662..c454505 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -246,7 +246,7 @@ class FormatLoader {
+++++             const tryResume = () => {
+++++                 if (videoReady && (audioReady || !this.npa)) {
+++++                     if (lastTime !== null) videoElement.currentTime = lastTime;
+++++-                    safeVideoPlay().catch(() => {});
++++++                    videoElement.play().catch(() => {});
+++++ 
+++++                     if (this.npa) {
+++++                         if (lastTime !== null) audioElement.currentTime = lastTime;
+++++@@ -387,32 +387,6 @@ function cleanupSync() {
+++++     stopSyncCheck();
+++++ }
+++++ 
+++++-async function safeVideoPlay() {
+++++-    if (!formatLoader.npa) return videoElement.play().catch(()=>{});
+++++-
+++++-    const tryPlay = async () => {
+++++-        const bufferedEnd = audioElement.buffered.length
+++++-            ? audioElement.buffered.end(audioElement.buffered.length - 1)
+++++-            : 0;
+++++-
+++++-        if (bufferedEnd >= videoElement.currentTime + 0.25) {
+++++-            videoElement.play().catch(()=>{});
+++++-        } else {
+++++-            // Wait until audio buffers enough
+++++-            await new Promise(resolve => {
+++++-                const onCanPlay = () => {
+++++-                    audioElement.removeEventListener('canplay', onCanPlay);
+++++-                    resolve();
+++++-                };
+++++-                audioElement.addEventListener('canplay', onCanPlay);
+++++-            });
+++++-            tryPlay();
+++++-        }
+++++-    };
+++++-
+++++-    tryPlay();
+++++-}
+++++-
+++++ videoElement.addEventListener("play", startSyncCheck);
+++++ videoElement.addEventListener("pause", stopSyncCheck);
+++++ 
+++++@@ -522,7 +496,7 @@ function resumeWhenBuffered() {
+++++         shouldResume = false
+++++         const t = videoElement.currentTime
+++++         if (formatLoader.npa) audioElement.currentTime = t
+++++-        safeVideoPlay().catch(()=>{})
++++++        videoElement.play().catch(()=>{})
+++++         if (formatLoader.npa) audioElement.play().catch(()=>{})
+++++     } else {
+++++         // Retry shortly until both ready
+++++@@ -568,16 +542,16 @@ async function playVideo() {
+++++ 
+++++         // Only play video immediately if no separate audio, otherwise wait for audio
+++++         if (!formatLoader.npa) {
+++++-            await safeVideoPlay();
++++++            await videoElement.play();
+++++         } else {
+++++             // Wait until audio can play
+++++             if (audioElement.readyState >= 2) {
+++++                 await audioElement.play();
+++++-                await safeVideoPlay();
++++++                await videoElement.play();
+++++             } else {
+++++                 audioElement.addEventListener('canplaythrough', async () => {
+++++                     await audioElement.play();
+++++-                    await safeVideoPlay();
++++++                    await videoElement.play();
+++++                 }, { once: true });
+++++             }
+++++         }
+++++@@ -656,7 +630,7 @@ document.addEventListener("keydown", async (event) => {
+++++         // Attempt to play video and audio
+++++         try {
+++++             if (videoElement.paused) {
+++++-                await safeVideoPlay(); // counts as user gesture
++++++                await videoElement.play(); // counts as user gesture
+++++                 if (audioElement.src && playManagers.audio.isActive()) {
+++++                     try {
+++++                         await audioElement.play();
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0024-more-state-mgt-fixes.patch b/patches/0024-more-state-mgt-fixes.patch
++++new file mode 100644
++++index 0000000..bb778c1
++++--- /dev/null
+++++++ b/patches/0024-more-state-mgt-fixes.patch
++++@@ -0,0 +1,63 @@
+++++From e24470042ace357fcaed748734036917e5ad44f9 Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Thu, 15 Jan 2026 10:21:19 +0300
+++++Subject: [PATCH 24/31] more state mgt fixes
+++++
+++++---
+++++ html/static/js/player.js | 20 +++++++++-----------
+++++ 1 file changed, 9 insertions(+), 11 deletions(-)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index c454505..e850d4b 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -486,12 +486,9 @@ videoElement.addEventListener("seeking", () => {
+++++ })
+++++ 
+++++ function resumeWhenBuffered() {
+++++-    if (!freezePlayback || !shouldResume) return
++++++    if (!freezePlayback || !shouldResume) return;
+++++ 
+++++-    const videoReady = videoElement.readyState >= 3
+++++-    const audioReady = !formatLoader.npa || audioElement.readyState >= 3
+++++-
+++++-    if (videoReady && audioReady) {
++++++    if (videoElement.readyState >= 2 && (!formatLoader.npa || audioElement.readyState >= 2)) {
+++++         freezePlayback = false
+++++         shouldResume = false
+++++         const t = videoElement.currentTime
+++++@@ -499,7 +496,6 @@ function resumeWhenBuffered() {
+++++         videoElement.play().catch(()=>{})
+++++         if (formatLoader.npa) audioElement.play().catch(()=>{})
+++++     } else {
+++++-        // Retry shortly until both ready
+++++         requestAnimationFrame(resumeWhenBuffered)
+++++     }
+++++ }
+++++@@ -592,10 +588,12 @@ videoElement.addEventListener("click", (event) => {
+++++     videoElement.focus();
+++++ });
+++++ 
+++++-videoElement.addEventListener("seeked", () => {
+++++-    if (formatLoader.npa) {
+++++-        audioElement.muted = false;
+++++-        audioElement.currentTime = videoElement.currentTime;
++++++videoElement.addEventListener("seeking", () => {
++++++    freezePlayback = true;
++++++    if (formatLoader.npa && !videoElement.paused) {
++++++        shouldResume = true;
++++++        videoElement.pause();
++++++        audioElement.pause();
+++++     }
+++++ });
+++++ 
+++++@@ -700,4 +698,4 @@ document.addEventListener('click', (event) => {
+++++   // Clear flag after seek settles
+++++   videoElement.addEventListener('seeked', () =>
+++++     setTimeout(() => userSeeking = false, 300), { once: true });
+++++-});
+++++\ No newline at end of file
++++++});
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0025-detach-audio-media-fetching-from-userInteracted.patch b/patches/0025-detach-audio-media-fetching-from-userInteracted.patch
++++new file mode 100644
++++index 0000000..fa261b6
++++--- /dev/null
+++++++ b/patches/0025-detach-audio-media-fetching-from-userInteracted.patch
++++@@ -0,0 +1,84 @@
+++++From 0034e2648ad2a7933530a38ce2211486f9ed4afa Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Thu, 15 Jan 2026 12:31:56 +0300
+++++Subject: [PATCH 25/31] detach audio media fetching from userInteracted
+++++
+++++---
+++++ html/static/js/player.js | 48 ++++++++++++++++++++++++++++------------
+++++ 1 file changed, 34 insertions(+), 14 deletions(-)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index e850d4b..2a57976 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -289,9 +289,13 @@ class FormatLoader {
+++++     }
+++++ }
+++++ 
+++++-
+++++ const formatLoader = new FormatLoader();
+++++ 
++++++if (formatLoader.npa?.url) {
++++++    audioElement.src = formatLoader.npa.url;
++++++    audioElement.load();
++++++}
++++++
+++++ class PlayManager {
+++++     constructor(media, isAudio) {
+++++         this.media = media;
+++++@@ -679,23 +683,39 @@ audioElement.setAttribute('preload', 'metadata');
+++++ new SubscribeButton(q("#subscribe"));
+++++ 
+++++ let userSeeking = false;
++++++
+++++ document.addEventListener('click', (event) => {
+++++-  const timestampEl = event.target.closest('[data-clickable-timestamp]');
+++++-  if (!timestampEl) return;
++++++    const timestampEl = event.target.closest('[data-clickable-timestamp]');
++++++    if (!timestampEl) return;
++++++
++++++    event.preventDefault();
++++++    const time = parseFloat(timestampEl.getAttribute('data-clickable-timestamp'));
++++++    if (isNaN(time)) return;
+++++ 
+++++-  event.preventDefault();
+++++-  const time = parseFloat(timestampEl.getAttribute('data-clickable-timestamp'));
+++++-  if (isNaN(time)) return;
++++++    userSeeking = true;
+++++ 
+++++-  // This single line stops the play/pause buffering loop
+++++-  userSeeking = true;
++++++    // Set times
++++++    videoElement.currentTime = time;
+++++ 
+++++-  videoElement.currentTime = time;
+++++-  if (formatLoader.npa) audioElement.currentTime = time;
++++++    if (formatLoader.npa?.url) {
++++++        audioElement.src = formatLoader.npa.url;
++++++        audioElement.load();
++++++        audioElement.currentTime = time;
++++++
++++++        // --- Natural delay: video cannot render past buffered audio ---
++++++        const waitForAudioBuffer = () => {
++++++            if (audioElement.buffered.length > 0) {
++++++                const start = audioElement.buffered.start(0);
++++++                if (videoElement.currentTime < start) videoElement.currentTime = start;
++++++            } else {
++++++                requestAnimationFrame(waitForAudioBuffer);
++++++            }
++++++        };
++++++        requestAnimationFrame(waitForAudioBuffer);
++++++    }
+++++ 
+++++-  window.history.replaceState(null, '', timestampEl.href);
++++++    window.history.replaceState(null, '', timestampEl.href);
+++++ 
+++++-  // Clear flag after seek settles
+++++-  videoElement.addEventListener('seeked', () =>
+++++-    setTimeout(() => userSeeking = false, 300), { once: true });
++++++    videoElement.addEventListener('seeked', () =>
++++++        setTimeout(() => userSeeking = false, 300), { once: true });
+++++ });
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0026-finally-fix-make-video-follow-audio-playback.patch b/patches/0026-finally-fix-make-video-follow-audio-playback.patch
++++new file mode 100644
++++index 0000000..ec5416a
++++--- /dev/null
+++++++ b/patches/0026-finally-fix-make-video-follow-audio-playback.patch
++++@@ -0,0 +1,852 @@
+++++From b0111e3bf1ab97f8459b9bf0ee09e7d8476d7e17 Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Thu, 15 Jan 2026 13:01:20 +0300
+++++Subject: [PATCH 26/31] finally fix make video follow audio playback
+++++
+++++---
+++++ html/static/js/player.js |  62 +++-
+++++ new.player.5             | 745 +++++++++++++++++++++++++++++++++++++++
+++++ 2 files changed, 793 insertions(+), 14 deletions(-)
+++++ create mode 100644 new.player.5
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index 2a57976..9a81a13 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -481,13 +481,38 @@ let freezePlayback = false
+++++ let shouldResume = false
+++++ 
+++++ videoElement.addEventListener("seeking", () => {
+++++-    freezePlayback = true
++++++    // --- New: delay video naturally if audio is ahead ---
++++++    if (formatLoader.npa) {
++++++        const targetTime = videoElement.currentTime;
++++++
++++++        const waitAudio = () => {
++++++            if (audioElement.buffered.length > 0) {
++++++                // Find the buffered range containing targetTime
++++++                let start = audioElement.buffered.start(0);
++++++                for (let i = 0; i < audioElement.buffered.length; i++) {
++++++                    if (audioElement.buffered.start(i) <= targetTime && audioElement.buffered.end(i) >= targetTime) {
++++++                        start = audioElement.buffered.start(i);
++++++                        break;
++++++                    }
++++++                }
++++++
++++++                if (videoElement.currentTime < start) videoElement.currentTime = start;
++++++            } else {
++++++                requestAnimationFrame(waitAudio);
++++++            }
++++++        };
++++++
++++++        requestAnimationFrame(waitAudio);
++++++    }
++++++
++++++    // --- Existing freezePlayback logic remains untouched ---
++++++    freezePlayback = true;
+++++     if (!videoElement.paused || (formatLoader.npa && !audioElement.paused)) {
+++++-        shouldResume = true
++++++        shouldResume = true;
+++++         videoElement.pause()
+++++         if (formatLoader.npa) audioElement.pause()
+++++     }
+++++-})
++++++});
+++++ 
+++++ function resumeWhenBuffered() {
+++++     if (!freezePlayback || !shouldResume) return;
+++++@@ -540,20 +565,29 @@ async function playVideo() {
+++++     try {
+++++         if (audioContext.state === 'suspended') await audioContext.resume();
+++++ 
+++++-        // Only play video immediately if no separate audio, otherwise wait for audio
+++++         if (!formatLoader.npa) {
++++++            // No separate audio, play video immediately
+++++             await videoElement.play();
+++++         } else {
+++++-            // Wait until audio can play
+++++-            if (audioElement.readyState >= 2) {
+++++-                await audioElement.play();
+++++-                await videoElement.play();
+++++-            } else {
+++++-                audioElement.addEventListener('canplaythrough', async () => {
+++++-                    await audioElement.play();
+++++-                    await videoElement.play();
+++++-                }, { once: true });
+++++-            }
++++++            // Separate audio exists: wait for audio buffer before playing
++++++            const waitAudioReady = () => new Promise(resolve => {
++++++                if (audioElement.buffered.length > 0) return resolve();
++++++
++++++                const check = () => {
++++++                    if (audioElement.buffered.length > 0) return resolve();
++++++                    requestAnimationFrame(check);
++++++                };
++++++                requestAnimationFrame(check);
++++++            });
++++++
++++++            await waitAudioReady();
++++++
++++++            // Sync times again to be safe
++++++            audioElement.currentTime = videoElement.currentTime;
++++++
++++++            // Attempt playback; browser may block until gesture
++++++            await audioElement.play().catch(() => {});
++++++            await videoElement.play();
+++++         }
+++++     } catch (e) {
+++++         console.error("Playback failed:", e);
+++++diff --git a/new.player.5 b/new.player.5
+++++new file mode 100644
+++++index 0000000..ded24c4
+++++--- /dev/null
++++++++ b/new.player.5
+++++@@ -0,0 +1,745 @@
++++++import { q, qa, ElemJS } from "/static/js/elemjs/elemjs.js";
++++++import { SubscribeButton } from "/static/js/modules/SubscribeButton.js";
++++++
++++++const videoElement = q("#video");
++++++videoElement.setAttribute("fetchpriority", "low");
++++++const audioElement = q("#audio");
++++++// Buffer audio aggressively
++++++audioElement.setAttribute("fetchpriority", "high");
++++++audioElement.preload = "auto";
++++++
++++++// Make video focusable
++++++videoElement.setAttribute("tabindex", "0");
++++++
++++++let userInteracted = false;
++++++document.addEventListener("click", () => { userInteracted = true; alignStreams(); }, { once: true });
++++++
++++++let syncCheckInterval = null;
++++++const videoFormats = new Map();
++++++const audioFormats = [];
++++++
++++++[...data.formatStreams, ...data.adaptiveFormats].forEach(f => {
++++++    f.isAdaptive = f.type.startsWith("video");
++++++    if (f.type.startsWith("video")) {
++++++        videoFormats.set(f.itag, f);
++++++    } else {
++++++        audioFormats.push(f);
++++++    }
++++++});
++++++
++++++// --- pre-warm all known origins ---
++++++videoFormats.forEach(vf => warmup(vf.url));
++++++audioFormats.forEach(af => warmup(af.url));
++++++
++++++// Update src from initial url page load
++++++try {
++++++    const src = videoElement.querySelector('source')?.src
++++++    const itag = videoElement.dataset.itag
++++++    const vf = itag && videoFormats.get(itag)
++++++    if (vf && src) vf.url = src
++++++} catch {}
++++++
++++++function getBestAudioFormat() {
++++++    function parseXtags(url) {
++++++        const urlParams = new URLSearchParams(url.split('?')[1] ?? '');
++++++        const xtags = urlParams.get('xtags') ?? '';
++++++        const parts = xtags.split(':');
++++++        let language = 'unknown';
++++++        let content = 'unknown';
++++++        for (const part of parts) {
++++++            if (part.startsWith('lang=')) {
++++++                language = part.replace('lang=', '');
++++++                if (language.includes('-')) language = language.split('-')[0];
++++++            }
++++++            if (part.startsWith('acont=')) content = part.replace('acont=', '');
++++++        }
++++++        return { language, content };
++++++    }
++++++
++++++    let best = null;
++++++
++++++    for (const f of audioFormats) {
++++++        if (!isValidUrl(f.url)) continue;
++++++        const { language, content } = parseXtags(f.url);
++++++        if (language === 'en' && content === 'original') {
++++++            if (!best || f.bitrate > best.bitrate) {
++++++                best = f;
++++++            }
++++++        }
++++++    }
++++++
++++++    if (!best) {
++++++        for (const f of audioFormats) {
++++++            if (!isValidUrl(f.url)) continue;
++++++            const { language } = parseXtags(f.url);
++++++            if (language === 'en') {
++++++                if (!best || f.bitrate > best.bitrate) {
++++++                    best = f;
++++++                }
++++++            }
++++++        }
++++++    }
++++++
++++++    if (!best) {
++++++        for (const f of audioFormats) {
++++++            if (!isValidUrl(f.url)) continue;
++++++            if (!best || f.bitrate > best.bitrate) {
++++++                best = f;
++++++            }
++++++        }
++++++    }
++++++
++++++    return best;
++++++}
++++++
++++++function isValidUrl(string) {
++++++    try {
++++++        new URL(string);
++++++        return true;
++++++    } catch (_) {
++++++        return false;
++++++    }
++++++}
++++++
++++++const warmedOrigins = new Set();
++++++
++++++function warmup(url) {
++++++    try {
++++++        const origin = new URL(url).origin;
++++++        if (warmedOrigins.has(origin)) return; // already done
++++++        warmedOrigins.add(origin);
++++++
++++++        // Preconnect: TCP + TLS
++++++        const preconnectLink = document.createElement("link");
++++++        preconnectLink.rel = "preconnect";
++++++        preconnectLink.href = origin;
++++++        document.head.appendChild(preconnectLink);
++++++
++++++        // DNS prefetch
++++++        const dnsLink = document.createElement("link");
++++++        dnsLink.rel = "dns-prefetch";
++++++        dnsLink.href = origin;
++++++        document.head.appendChild(dnsLink);
++++++
++++++    } catch {}
++++++}
++++++
++++++function loadMediaWithRetry(mediaElement, url, retries = 6) {
++++++    let attempt = 0;
++++++    let locked = false;
++++++
++++++    function tryLoad() {
++++++        // warm up connection BEFORE requesting the media
++++++        warmup(url);
++++++
++++++        mediaElement.src = url;
++++++        mediaElement.load();
++++++
++++++        mediaElement.onplaying = () => { locked = true; };
++++++        mediaElement.oncanplay = () => { locked = true; };
++++++
++++++        mediaElement.onerror = () => {
++++++            if (locked) return;
++++++            attempt++;
++++++            console.error("Media load failed:", url);
++++++
++++++            if (attempt < retries) {
++++++                setTimeout(tryLoad, 1000 * attempt); // gradual backoff, same logic, faster start
++++++            } else {
++++++                console.error("Failed to load media after", retries, "attempts.");
++++++            }
++++++        };
++++++    }
++++++
++++++    tryLoad();
++++++}
++++++
++++++function alignStreams() {
++++++    if (!audioElement.src || !videoElement.src) return;
++++++    const t = Math.max(audioElement.currentTime || 0, videoElement.currentTime || 0);
++++++    audioElement.currentTime = t;
++++++    videoElement.currentTime = t;
++++++}
++++++
++++++
++++++let pipReady = false;
++++++
++++++document.addEventListener("visibilitychange", async () => {
++++++    const video = document.querySelector("video");
++++++    if (!video || !document.pictureInPictureEnabled) return;
++++++
++++++    if (document.hidden && !document.pictureInPictureElement && !video.paused) {
++++++        if (!pipReady) {
++++++            console.warn("PiP blocked. Waiting for user gesture to enable re-entry.");
++++++            return;
++++++        }
++++++
++++++        try {
++++++            await video.requestPictureInPicture();
++++++        } catch (err) {
++++++            console.error("PiP request failed:", err);
++++++        }
++++++    }
++++++});
++++++
++++++document.addEventListener("leavepictureinpicture", () => {
++++++    pipReady = false;
++++++});
++++++
++++++document.addEventListener("click", () => {
++++++    pipReady = true;
++++++});
++++++
++++++const audioContext = new AudioContext();
++++++
++++++class FormatLoader {
++++++    constructor() {
++++++        this.npv = videoFormats.get(videoElement.getAttribute("data-itag"));
++++++        this.npa = null;
++++++
++++++        // --- FIX: attach best audio on initial load if video has no audio ---
++++++        const hasAudio = this.npv.type && (this.npv.type.includes("mp4a") || this.npv.type.includes("audio"));
++++++        if (!hasAudio) {
++++++            const bestAudio = getBestAudioFormat();
++++++            if (bestAudio) {
++++++                this.npa = bestAudio;
++++++            }
++++++        }
++++++
++++++        // Load media immediately
++++++        requestAnimationFrame(() => this.update());
++++++    }
++++++
++++++    play(itag, isQualitySwitch = false) {
++++++        this.npv = videoFormats.get(itag);
++++++        this.npa = null;
++++++
++++++        const hasAudio = this.npv.type && (this.npv.type.includes("mp4a") || this.npv.type.includes("audio"));
++++++        if (!hasAudio) {
++++++            const bestAudio = getBestAudioFormat();
++++++            if (bestAudio && bestAudio.url !== this.npv.url) {
++++++                this.npa = bestAudio;
++++++            }
++++++        }
++++++
++++++        this.update(isQualitySwitch);
++++++    }
++++++
++++++    update(isQualitySwitch = false) {
++++++        if (!userInteracted) return;
++++++        cleanupSync();
++++++
++++++        const lastTime = isQualitySwitch ? videoElement.currentTime : null;
++++++
++++++        if (!this.npv.url) {
++++++            console.error("No URL for video format! Cannot load.");
++++++            return;
++++++        }
++++++
++++++        if (isQualitySwitch) {
++++++            videoElement.pause();
++++++            stopSyncCheck();
++++++
++++++            let videoReady = false;
++++++            let audioReady = false;
++++++
++++++            const tryResume = () => {
++++++                if (videoReady && (audioReady || !this.npa)) {
++++++                    if (lastTime !== null) videoElement.currentTime = lastTime;
++++++                    videoElement.play().catch(() => {});
++++++
++++++                    if (this.npa) {
++++++                        if (lastTime !== null) audioElement.currentTime = lastTime;
++++++                        audioElement.play().catch(() => {});
++++++                    }
++++++
++++++                    startSyncCheck();
++++++                }
++++++            };
++++++
++++++            videoElement.src = this.npv.url;
++++++            videoElement.load();
++++++            videoElement.addEventListener('canplaythrough', () => {
++++++                videoReady = true;
++++++                tryResume();
++++++            }, { once: true });
++++++
++++++            if (this.npa) {
++++++                audioElement.src = this.npa.url;
++++++                audioElement.load();
++++++                audioElement.addEventListener('canplaythrough', () => {
++++++                    audioReady = true;
++++++                    tryResume();
++++++                }, { once: true });
++++++            } else {
++++++                audioElement.pause();
++++++                audioElement.removeAttribute("src");
++++++                audioReady = true;
++++++            }
++++++
++++++        } else {
++++++            loadMediaWithRetry(videoElement, this.npv.url);
++++++
++++++            if (this.npa) loadMediaWithRetry(audioElement, this.npa.url);
++++++            else {
++++++                audioElement.pause();
++++++                audioElement.removeAttribute("src");
++++++            }
++++++        }
++++++    }
++++++}
++++++
++++++const formatLoader = new FormatLoader();
++++++
++++++if (formatLoader.npa?.url) {
++++++    audioElement.src = formatLoader.npa.url;
++++++    audioElement.load();
++++++}
++++++
++++++class PlayManager {
++++++    constructor(media, isAudio) {
++++++        this.media = media;
++++++        this.isAudio = isAudio;
++++++    }
++++++
++++++    isActive() {
++++++        return !this.isAudio || formatLoader.npa;
++++++    }
++++++
++++++    play() {
++++++        if (this.isActive()) this.media.play();
++++++    }
++++++
++++++    pause() {
++++++        if (this.isActive()) this.media.pause();
++++++    }
++++++}
++++++
++++++const playManagers = {
++++++    video: new PlayManager(videoElement, false),
++++++    audio: new PlayManager(audioElement, true)
++++++};
++++++
++++++class QualitySelect extends ElemJS {
++++++    constructor() {
++++++        super(q("#quality-select"));
++++++        this.initialized = false;
++++++
++++++        // Defer until DOM & videoFormats ready
++++++        requestAnimationFrame(() => {
++++++            const saved = localStorage.getItem("lastQuality");
++++++
++++++            // Only set value if the option exists
++++++            if (saved && this.element.querySelector(`option[value="${saved}"]`)) {
++++++                this.element.value = saved;
++++++
++++++                if (videoElement.readyState >= 1) {
++++++                    formatLoader.play(saved, true);
++++++                } else {
++++++                    videoElement.addEventListener("loadedmetadata", () => {
++++++                        formatLoader.play(saved, true);
++++++                    }, { once: true });
++++++                }
++++++            }
++++++
++++++            this.initialized = true;
++++++        });
++++++
++++++        this.on("input", this.setFormat.bind(this));
++++++    }
++++++
++++++    setFormat() {
++++++        if (!this.initialized) return;
++++++
++++++        const itag = this.element.value;
++++++        localStorage.setItem("lastQuality", itag);
++++++
++++++        formatLoader.play(itag, true);
++++++        videoElement.focus();
++++++    }
++++++}
++++++
++++++new QualitySelect();
++++++
++++++const ignoreNext = { play: 0 };
++++++
++++++function startSyncCheck() {
++++++    if (syncCheckInterval) clearInterval(syncCheckInterval);
++++++
++++++    // Only start syncing if audio is ready or theres no separate audio
++++++    if (formatLoader.npa && audioElement.readyState < 2) {
++++++        audioElement.addEventListener('canplaythrough', startSyncCheck, { once: true });
++++++        return;
++++++    }
++++++
++++++    syncCheckInterval = setInterval(() => {
++++++        if (!videoElement.paused && !audioElement.paused) {
++++++            const drift = Math.abs(videoElement.currentTime - audioElement.currentTime);
++++++            if (drift > 0.1) {
++++++                audioElement.currentTime = videoElement.currentTime;
++++++            }
++++++        }
++++++    }, 1000);
++++++}
++++++
++++++function stopSyncCheck() {
++++++    if (syncCheckInterval) clearInterval(syncCheckInterval);
++++++    syncCheckInterval = null;
++++++}
++++++
++++++function cleanupSync() {
++++++    stopSyncCheck();
++++++}
++++++
++++++videoElement.addEventListener("play", startSyncCheck);
++++++videoElement.addEventListener("pause", stopSyncCheck);
++++++
++++++function playbackIntervention(event) {
++++++    const target = event.target;
++++++    const other = target === videoElement ? audioElement : videoElement;
++++++
++++++    // Prevent race while media is buffering or not ready
++++++    if (target.readyState < 2) return;
++++++
++++++    // Only sync audio for non-SB manual seeks
++++++    if (audioElement.src && !ignoreNext[event.type]--) {
++++++        if (event.type === "seeked") {
++++++            const targetTime = target.currentTime;
++++++            other.currentTime = targetTime;
++++++
++++++            setTimeout(() => {
++++++                if (Math.abs(videoElement.currentTime - audioElement.currentTime) > 0.1) {
++++++                    videoElement.currentTime = targetTime;
++++++                    audioElement.currentTime = targetTime;
++++++                }
++++++            }, 100);
++++++        } else if (event.type === "play") {
++++++            if (other.readyState >= 2) {
++++++                playManagers[other.tagName.toLowerCase()].play();
++++++            }
++++++        } else if (event.type === "pause") {
++++++            other.pause();
++++++        } else if (event.type === "ratechange") {
++++++            other.playbackRate = target.playbackRate;
++++++        }
++++++    }
++++++}
++++++
++++++function debounce(func, wait) {
++++++    let timeoutId;
++++++    return (...args) => {
++++++        clearTimeout(timeoutId);
++++++        timeoutId = setTimeout(() => func(...args), wait);
++++++    };
++++++}
++++++
++++++const debouncedPlaybackIntervention = debounce(playbackIntervention, 100);
++++++["pause", "play", "seeked"].forEach(eventName =>
++++++    videoElement.addEventListener(eventName, debouncedPlaybackIntervention)
++++++);
++++++["canplaythrough", "waiting", "stalled", "ratechange"].forEach(eventName => {
++++++    videoElement.addEventListener(eventName, playbackIntervention);
++++++    audioElement.addEventListener(eventName, playbackIntervention);
++++++});
++++++
++++++// Error handling
++++++videoElement.addEventListener("error", (e) => {
++++++    console.error("Video loading error:", e);
++++++});
++++++audioElement.addEventListener("error", (e) => {
++++++    console.error("Audio loading error:", e);
++++++});
++++++
++++++// Loading feedback
++++++videoElement.addEventListener("waiting", () => console.log("Video buffering..."));
++++++audioElement.addEventListener("waiting", () => console.log("Audio buffering..."));
++++++
++++++// Fix reverb on buffering mid-playback
++++++// --- Robust mid-playback buffering isolation ---
++++++let wasPlayingBeforeBuffer = false;
++++++
++++++videoElement.addEventListener("waiting", () => {
++++++    if (!videoElement.paused && videoElement.currentTime > 0) {
++++++        wasPlayingBeforeBuffer = true;
++++++
++++++        if (!audioElement.paused && formatLoader.npa) {
++++++            audioElement.muted = true;
++++++        }
++++++    }
++++++});
++++++
++++++videoElement.addEventListener("playing", () => {
++++++    if (wasPlayingBeforeBuffer && formatLoader.npa) {
++++++        wasPlayingBeforeBuffer = false;
++++++        audioElement.muted = false;
++++++        audioElement.currentTime = videoElement.currentTime;
++++++    }
++++++});
++++++
++++++// --- Robust smooth seek for separate audio/video ---
++++++let freezePlayback = false
++++++let shouldResume = false
++++++
++++++videoElement.addEventListener("seeking", () => {
++++++    // --- New: delay video naturally if audio is ahead ---
++++++    if (formatLoader.npa) {
++++++        const targetTime = videoElement.currentTime;
++++++
++++++        const waitAudio = () => {
++++++            if (audioElement.buffered.length > 0) {
++++++                // Find the buffered range containing targetTime
++++++                let start = audioElement.buffered.start(0);
++++++                for (let i = 0; i < audioElement.buffered.length; i++) {
++++++                    if (audioElement.buffered.start(i) <= targetTime && audioElement.buffered.end(i) >= targetTime) {
++++++                        start = audioElement.buffered.start(i);
++++++                        break;
++++++                    }
++++++                }
++++++
++++++                if (videoElement.currentTime < start) videoElement.currentTime = start;
++++++            } else {
++++++                requestAnimationFrame(waitAudio);
++++++            }
++++++        };
++++++
++++++        requestAnimationFrame(waitAudio);
++++++    }
++++++
++++++    // --- Existing freezePlayback logic remains untouched ---
++++++    freezePlayback = true;
++++++    if (!videoElement.paused || (formatLoader.npa && !audioElement.paused)) {
++++++        shouldResume = true;
++++++        videoElement.pause()
++++++        if (formatLoader.npa) audioElement.pause()
++++++    }
++++++});
++++++
++++++function resumeWhenBuffered() {
++++++    if (!freezePlayback || !shouldResume) return;
++++++
++++++    if (videoElement.readyState >= 2 && (!formatLoader.npa || audioElement.readyState >= 2)) {
++++++        freezePlayback = false
++++++        shouldResume = false
++++++        const t = videoElement.currentTime
++++++        if (formatLoader.npa) audioElement.currentTime = t
++++++        videoElement.play().catch(()=>{})
++++++        if (formatLoader.npa) audioElement.play().catch(()=>{})
++++++    } else {
++++++        requestAnimationFrame(resumeWhenBuffered)
++++++    }
++++++}
++++++
++++++videoElement.addEventListener("seeking", () => {
++++++    requestAnimationFrame(resumeWhenBuffered)
++++++})
++++++
++++++
++++++const videoObserver = new IntersectionObserver((entries) => {
++++++    entries.forEach(entry => {
++++++        if (entry.isIntersecting) {
++++++            loadMediaWithRetry(videoElement, formatLoader.npv.url);
++++++            if (formatLoader.npa) {
++++++                loadMediaWithRetry(audioElement, formatLoader.npa.url);
++++++            }
++++++            videoObserver.disconnect();
++++++        }
++++++    });
++++++}, { threshold: 0.5 });
++++++
++++++videoObserver.observe(videoElement);
++++++
++++++function relativeSeek(seconds) {
++++++    const t = videoElement.currentTime + seconds;
++++++    videoElement.currentTime = t;
++++++    if (formatLoader.npa) audioElement.currentTime = t;
++++++}
++++++
++++++async function playVideo() {
++++++    if (!userInteracted) return;
++++++    if (!videoElement.paused) return;
++++++
++++++    const targetTime = videoElement.currentTime;
++++++    audioElement.currentTime = targetTime;
++++++    ignoreNext.play = 2;
++++++
++++++    try {
++++++        if (audioContext.state === 'suspended') await audioContext.resume();
++++++
++++++        // Only play video immediately if no separate audio, otherwise wait for audio
++++++        if (!formatLoader.npa) {
++++++            await videoElement.play();
++++++        } else {
++++++            // Wait until audio can play
++++++            if (audioElement.readyState >= 2) {
++++++                await audioElement.play();
++++++                await videoElement.play();
++++++            } else {
++++++                audioElement.addEventListener('canplaythrough', async () => {
++++++                    await audioElement.play();
++++++                    await videoElement.play();
++++++                }, { once: true });
++++++            }
++++++        }
++++++    } catch (e) {
++++++        console.error("Playback failed:", e);
++++++    }
++++++}
++++++
++++++function togglePlaying() {
++++++    if (videoElement.paused) {
++++++        if (!userInteracted) return;
++++++        playVideo();
++++++    } else {
++++++        videoElement.pause();
++++++        if (formatLoader.npa) audioElement.pause(); // also pause separate audio
++++++    }
++++++}
++++++
++++++function toggleFullScreen() {
++++++    if (document.fullscreenElement || document.webkitFullscreenElement) {
++++++        (document.exitFullscreen || document.webkitExitFullscreen).call(document);
++++++    } else {
++++++        (videoElement.requestFullscreen || videoElement.webkitRequestFullscreen).call(videoElement);
++++++    }
++++++}
++++++
++++++//  Critical: Track interaction and refocus
++++++videoElement.addEventListener("pointerdown", () => {
++++++    userInteracted = true
++++++    videoElement.focus();
++++++});
++++++
++++++videoElement.addEventListener("click", (event) => {
++++++    event.preventDefault();
++++++    togglePlaying();
++++++    videoElement.lastInteraction = Date.now(); // Track last click
++++++    videoElement.focus();
++++++});
++++++
++++++videoElement.addEventListener("seeking", () => {
++++++    freezePlayback = true;
++++++    if (formatLoader.npa && !videoElement.paused) {
++++++        shouldResume = true;
++++++        videoElement.pause();
++++++        audioElement.pause();
++++++    }
++++++});
++++++
++++++//  Capture spacebar early and forcefully
++++++const keyActions = new Map([
++++++    ["j", () => relativeSeek(-10)],
++++++    ["n", () => relativeSeek(-10)],
++++++    ["k", togglePlaying],
++++++    ["p", togglePlaying],
++++++    [" ", togglePlaying],
++++++    ["e", togglePlaying],
++++++    ["l", () => relativeSeek(10)],
++++++    ["o", () => relativeSeek(10)],
++++++    ["ArrowLeft", () => relativeSeek(-5)],
++++++    ["ArrowRight", () => relativeSeek(5)],
++++++    ["f", toggleFullScreen]
++++++]);
++++++
++++++// Use capture phase to intercept spacebar before browser scrolls
++++++document.addEventListener("keydown", async (event) => {
++++++    // Ignore inputs and Ctrl combinations
++++++    if (["INPUT", "SELECT", "TEXTAREA", "BUTTON"].includes(event.target.tagName) || event.ctrlKey) {
++++++        return;
++++++    }
++++++
++++++    if (event.key === "k") {
++++++        event.preventDefault();
++++++
++++++        // Track last interaction so other logic (like spacebar) sees a gesture
++++++        videoElement.lastInteraction = Date.now();
++++++
++++++        // Attempt to play video and audio
++++++        try {
++++++            if (videoElement.paused) {
++++++                await videoElement.play(); // counts as user gesture
++++++                if (audioElement.src && playManagers.audio.isActive()) {
++++++                    try {
++++++                        await audioElement.play();
++++++                    } catch (e) {
++++++                        console.warn("Audio blocked until user gesture:", e);
++++++                    }
++++++                }
++++++            } else {
++++++                videoElement.pause();
++++++                audioElement.pause();
++++++            }
++++++        } catch (e) {
++++++            console.warn("Playback blocked by browser:", e);
++++++        }
++++++
++++++        return; // prevent further handling
++++++    }
++++++
++++++    const action = keyActions.get(event.key);
++++++    if (action) {
++++++        if (event.key === " ") {
++++++            const isActive = document.activeElement === videoElement;
++++++            const recentlyClicked = Date.now() - (videoElement.lastInteraction || 0) < 15000;
++++++            if (!isActive && !recentlyClicked) return;
++++++            event.preventDefault();
++++++        }
++++++
++++++        action();
++++++        event.preventDefault();
++++++    }
++++++}, true); // capture phase: critical for gesture detection
++++++
++++++
++++++if ('mediaSession' in navigator) {
++++++    navigator.mediaSession.metadata = new MediaMetadata({
++++++        title: 'Video Title',
++++++        artist: 'Artist Name',
++++++        album: 'Album Name',
++++++    });
++++++
++++++    navigator.mediaSession.setActionHandler('play', togglePlaying);
++++++    navigator.mediaSession.setActionHandler('pause', togglePlaying);
++++++}
++++++
++++++videoElement.setAttribute('preload', 'metadata');
++++++audioElement.setAttribute('preload', 'metadata');
++++++
++++++new SubscribeButton(q("#subscribe"));
++++++
++++++let userSeeking = false;
++++++
++++++document.addEventListener('click', (event) => {
++++++    const timestampEl = event.target.closest('[data-clickable-timestamp]');
++++++    if (!timestampEl) return;
++++++
++++++    event.preventDefault();
++++++    const time = parseFloat(timestampEl.getAttribute('data-clickable-timestamp'));
++++++    if (isNaN(time)) return;
++++++
++++++    userSeeking = true;
++++++
++++++    // Set times
++++++    videoElement.currentTime = time;
++++++
++++++    if (formatLoader.npa?.url) {
++++++        audioElement.src = formatLoader.npa.url;
++++++        audioElement.load();
++++++        audioElement.currentTime = time;
++++++
++++++        // --- Natural delay: video cannot render past buffered audio ---
++++++        const waitForAudioBuffer = () => {
++++++            if (audioElement.buffered.length > 0) {
++++++                const start = audioElement.buffered.start(0);
++++++                if (videoElement.currentTime < start) videoElement.currentTime = start;
++++++            } else {
++++++                requestAnimationFrame(waitForAudioBuffer);
++++++            }
++++++        };
++++++        requestAnimationFrame(waitForAudioBuffer);
++++++    }
++++++
++++++    window.history.replaceState(null, '', timestampEl.href);
++++++
++++++    videoElement.addEventListener('seeked', () =>
++++++        setTimeout(() => userSeeking = false, 300), { once: true });
++++++});
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0027-DRY-finally-fix-make-video-follow-audio-playback.patch b/patches/0027-DRY-finally-fix-make-video-follow-audio-playback.patch
++++new file mode 100644
++++index 0000000..1384512
++++--- /dev/null
+++++++ b/patches/0027-DRY-finally-fix-make-video-follow-audio-playback.patch
++++@@ -0,0 +1,142 @@
+++++From 8d20f84b2133de09d444cfc814354ee4b539a8f8 Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Thu, 15 Jan 2026 13:25:30 +0300
+++++Subject: [PATCH 27/31] DRY: finally fix make video follow audio playback
+++++
+++++---
+++++ html/static/js/player.js | 88 ++++++++++++++--------------------------
+++++ 1 file changed, 31 insertions(+), 57 deletions(-)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index 9a81a13..887a1bb 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -425,6 +425,32 @@ function playbackIntervention(event) {
+++++     }
+++++ }
+++++ 
++++++async function waitForAudioThenPlay(videoEl, audioEl) {
++++++    if (!formatLoader.npa) {
++++++        // No separate audio, play video immediately
++++++        await videoEl.play();
++++++        return;
++++++    }
++++++
++++++    // Wait until audio has at least one buffered range
++++++    await new Promise(resolve => {
++++++        if (audioEl.buffered.length > 0) return resolve();
++++++
++++++        const check = () => {
++++++            if (audioEl.buffered.length > 0) return resolve();
++++++            requestAnimationFrame(check);
++++++        };
++++++        requestAnimationFrame(check);
++++++    });
++++++
++++++    // Sync times
++++++    audioEl.currentTime = videoEl.currentTime;
++++++
++++++    // Attempt playback; browser may block until gesture
++++++    await audioEl.play().catch(() => {});
++++++    await videoEl.play();
++++++}
++++++
+++++ function debounce(func, wait) {
+++++     let timeoutId;
+++++     return (...args) => {
+++++@@ -480,29 +506,11 @@ videoElement.addEventListener("playing", () => {
+++++ let freezePlayback = false
+++++ let shouldResume = false
+++++ 
+++++-videoElement.addEventListener("seeking", () => {
++++++videoElement.addEventListener("seeking", async (event) => {
+++++     // --- New: delay video naturally if audio is ahead ---
+++++     if (formatLoader.npa) {
+++++         const targetTime = videoElement.currentTime;
+++++-
+++++-        const waitAudio = () => {
+++++-            if (audioElement.buffered.length > 0) {
+++++-                // Find the buffered range containing targetTime
+++++-                let start = audioElement.buffered.start(0);
+++++-                for (let i = 0; i < audioElement.buffered.length; i++) {
+++++-                    if (audioElement.buffered.start(i) <= targetTime && audioElement.buffered.end(i) >= targetTime) {
+++++-                        start = audioElement.buffered.start(i);
+++++-                        break;
+++++-                    }
+++++-                }
+++++-
+++++-                if (videoElement.currentTime < start) videoElement.currentTime = start;
+++++-            } else {
+++++-                requestAnimationFrame(waitAudio);
+++++-            }
+++++-        };
+++++-
+++++-        requestAnimationFrame(waitAudio);
++++++        await waitForAudioThenPlay(videoElement, audioElement);
+++++     }
+++++ 
+++++     // --- Existing freezePlayback logic remains untouched ---
+++++@@ -564,31 +572,7 @@ async function playVideo() {
+++++ 
+++++     try {
+++++         if (audioContext.state === 'suspended') await audioContext.resume();
+++++-
+++++-        if (!formatLoader.npa) {
+++++-            // No separate audio, play video immediately
+++++-            await videoElement.play();
+++++-        } else {
+++++-            // Separate audio exists: wait for audio buffer before playing
+++++-            const waitAudioReady = () => new Promise(resolve => {
+++++-                if (audioElement.buffered.length > 0) return resolve();
+++++-
+++++-                const check = () => {
+++++-                    if (audioElement.buffered.length > 0) return resolve();
+++++-                    requestAnimationFrame(check);
+++++-                };
+++++-                requestAnimationFrame(check);
+++++-            });
+++++-
+++++-            await waitAudioReady();
+++++-
+++++-            // Sync times again to be safe
+++++-            audioElement.currentTime = videoElement.currentTime;
+++++-
+++++-            // Attempt playback; browser may block until gesture
+++++-            await audioElement.play().catch(() => {});
+++++-            await videoElement.play();
+++++-        }
++++++        await waitForAudioThenPlay(videoElement, audioElement);
+++++     } catch (e) {
+++++         console.error("Playback failed:", e);
+++++     }
+++++@@ -718,7 +702,7 @@ new SubscribeButton(q("#subscribe"));
+++++ 
+++++ let userSeeking = false;
+++++ 
+++++-document.addEventListener('click', (event) => {
++++++document.addEventListener('click', async (event) => {
+++++     const timestampEl = event.target.closest('[data-clickable-timestamp]');
+++++     if (!timestampEl) return;
+++++ 
+++++@@ -735,17 +719,7 @@ document.addEventListener('click', (event) => {
+++++         audioElement.src = formatLoader.npa.url;
+++++         audioElement.load();
+++++         audioElement.currentTime = time;
+++++-
+++++-        // --- Natural delay: video cannot render past buffered audio ---
+++++-        const waitForAudioBuffer = () => {
+++++-            if (audioElement.buffered.length > 0) {
+++++-                const start = audioElement.buffered.start(0);
+++++-                if (videoElement.currentTime < start) videoElement.currentTime = start;
+++++-            } else {
+++++-                requestAnimationFrame(waitForAudioBuffer);
+++++-            }
+++++-        };
+++++-        requestAnimationFrame(waitForAudioBuffer);
++++++        await waitForAudioThenPlay(videoElement, audioElement);
+++++     }
+++++ 
+++++     window.history.replaceState(null, '', timestampEl.href);
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0028-fix-media-playback-race-issues.patch b/patches/0028-fix-media-playback-race-issues.patch
++++new file mode 100644
++++index 0000000..288f212
++++--- /dev/null
+++++++ b/patches/0028-fix-media-playback-race-issues.patch
++++@@ -0,0 +1,92 @@
+++++From e018e0a7778df718c0283553b1b372b8537ec3ac Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Thu, 15 Jan 2026 18:42:46 +0300
+++++Subject: [PATCH 28/31] fix media playback race issues
+++++
+++++---
+++++ html/static/js/player.js | 43 ++++++++++++++++++++++++++++++----------
+++++ 1 file changed, 33 insertions(+), 10 deletions(-)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index 887a1bb..4f02dba 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -426,6 +426,7 @@ function playbackIntervention(event) {
+++++ }
+++++ 
+++++ async function waitForAudioThenPlay(videoEl, audioEl) {
++++++    if (videoEl.paused === false) return;
+++++     if (!formatLoader.npa) {
+++++         // No separate audio, play video immediately
+++++         await videoEl.play();
+++++@@ -443,12 +444,28 @@ async function waitForAudioThenPlay(videoEl, audioEl) {
+++++         requestAnimationFrame(check);
+++++     });
+++++ 
++++++    // Critical: re-check paused state after waiting  browser might have auto-paused or spam happened
++++++    if (!videoEl.paused) return;
++++++
+++++     // Sync times
+++++     audioEl.currentTime = videoEl.currentTime;
+++++ 
+++++     // Attempt playback; browser may block until gesture
+++++-    await audioEl.play().catch(() => {});
+++++-    await videoEl.play();
++++++    try {
++++++        await audioEl.play();
++++++    } catch (err) {
++++++        if (err.name !== 'AbortError') {
++++++            console.warn("Audio play interrupted:", err);
++++++        }
++++++    }
++++++
++++++    try {
++++++        await videoEl.play();
++++++    } catch (err) {
++++++        if (err.name !== 'AbortError') {
++++++            console.warn("Video play interrupted:", err);
++++++        }
++++++    }
+++++ }
+++++ 
+++++ function debounce(func, wait) {
+++++@@ -562,22 +579,28 @@ function relativeSeek(seconds) {
+++++     if (formatLoader.npa) audioElement.currentTime = t;
+++++ }
+++++ 
+++++-async function playVideo() {
++++++// Near the top
++++++const debouncedPlayVideo = debounce(async () => {
+++++     if (!userInteracted) return;
+++++     if (!videoElement.paused) return;
+++++ 
+++++-    const targetTime = videoElement.currentTime;
+++++-    audioElement.currentTime = targetTime;
+++++-    ignoreNext.play = 2;
+++++-
+++++     try {
+++++         if (audioContext.state === 'suspended') await audioContext.resume();
++++++
+++++         await waitForAudioThenPlay(videoElement, audioElement);
+++++-    } catch (e) {
+++++-        console.error("Playback failed:", e);
++++++    } catch (err) {
++++++        if (err.name === 'AbortError') {
++++++            // Expected during rapid seeks  silent ignore
++++++            return;
++++++        }
++++++        console.error("Playback failed:", err);
+++++     }
+++++-}
++++++}, 100);
+++++ 
++++++// Then change playVideo to:
++++++async function playVideo() {
++++++    debouncedPlayVideo();
++++++}
+++++ 
+++++ function togglePlaying() {
+++++     if (videoElement.paused) {
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0029-replace-alignment-polling-with-timeupdate.patch b/patches/0029-replace-alignment-polling-with-timeupdate.patch
++++new file mode 100644
++++index 0000000..8e7867b
++++--- /dev/null
+++++++ b/patches/0029-replace-alignment-polling-with-timeupdate.patch
++++@@ -0,0 +1,45 @@
+++++From 60a326a1ec7821314646cd768179a16923be2078 Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Thu, 15 Jan 2026 21:06:42 +0300
+++++Subject: [PATCH 29/31] replace alignment polling with timeupdate
+++++
+++++---
+++++ html/static/js/player.js | 11 ++++++-----
+++++ 1 file changed, 6 insertions(+), 5 deletions(-)
+++++
+++++diff --git a/html/static/js/player.js b/html/static/js/player.js
+++++index 4f02dba..78bcafe 100644
+++++--- a/html/static/js/player.js
++++++++ b/html/static/js/player.js
+++++@@ -364,22 +364,23 @@ new QualitySelect();
+++++ const ignoreNext = { play: 0 };
+++++ 
+++++ function startSyncCheck() {
+++++-    if (syncCheckInterval) clearInterval(syncCheckInterval);
+++++-
+++++-    // Only start syncing if audio is ready or theres no separate audio
++++++    // Only start syncing if audio is ready or theres no separate audio
+++++     if (formatLoader.npa && audioElement.readyState < 2) {
+++++         audioElement.addEventListener('canplaythrough', startSyncCheck, { once: true });
+++++         return;
+++++     }
+++++ 
+++++-    syncCheckInterval = setInterval(() => {
++++++    const sync = () => {
+++++         if (!videoElement.paused && !audioElement.paused) {
+++++             const drift = Math.abs(videoElement.currentTime - audioElement.currentTime);
+++++             if (drift > 0.1) {
+++++                 audioElement.currentTime = videoElement.currentTime;
+++++             }
+++++         }
+++++-    }, 1000);
++++++    };
++++++
++++++    videoElement.removeEventListener('timeupdate', sync);
++++++    videoElement.addEventListener('timeupdate', sync);
+++++ }
+++++ 
+++++ function stopSyncCheck() {
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0030-add-comments.patch b/patches/0030-add-comments.patch
++++new file mode 100644
++++index 0000000..cf54ef7
++++--- /dev/null
+++++++ b/patches/0030-add-comments.patch
++++@@ -0,0 +1,352 @@
+++++From 5c6585c55ff434b593cde6df0296525ccf5adea7 Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Fri, 16 Jan 2026 12:49:59 +0300
+++++Subject: [PATCH 30/31] add comments
+++++
+++++---
+++++ api/video.js                   |  40 +++++++++-
+++++ html/static/js/comments.js     |  79 ++++++++++++++++++
+++++ pug/video.pug                  |  23 +++++-
+++++ sass/includes/_video-page.sass | 142 +++++++++++++++++++++++++++++++++
+++++ 4 files changed, 282 insertions(+), 2 deletions(-)
+++++ create mode 100644 html/static/js/comments.js
+++++
+++++diff --git a/api/video.js b/api/video.js
+++++index 859ca0a..1457579 100644
+++++--- a/api/video.js
++++++++ b/api/video.js
+++++@@ -126,8 +126,11 @@ module.exports = [
+++++ 				? request(`${instanceOrigin}/api/v1/videos/${id}`).then(res => res.json())
+++++ 				: JSON.parse(new URLSearchParams(body.toString()).get("video"));
+++++ 
++++++			const commentsFuture = request(`${instanceOrigin}/api/v1/comments/${id}`).then(res => res.json());
++++++
+++++ 			try {
+++++ 				const video = await videoFuture;
++++++				const commentsData = await commentsFuture;
+++++ 				if (!video) throw new MessageError("The instance returned null.");
+++++ 				if (video.error) throw new InstanceError(video.error, video.identifier);
+++++ 
+++++@@ -167,7 +170,7 @@ module.exports = [
+++++ 
+++++ 				return render(200, "pug/video.pug", {
+++++ 					req, url, video, formats, subscribed, instanceOrigin, mediaFragment, autoplay, continuous,
+++++-					sessionWatched, sessionWatchedNext, settings
++++++					sessionWatched, sessionWatchedNext, settings, comments: commentsData.comments || []
+++++ 				});
+++++ 
+++++ 			} catch (error) {
+++++@@ -183,5 +186,40 @@ module.exports = [
+++++ 				return render(500, "pug/video.pug", {video: {videoId: id}, error: true, message, req, settings});
+++++ 			}
+++++ 		}
++++++	},
++++++	{
++++++		route: "/api/comments", methods: ["GET"], code: async ({req, url}) => {
++++++			const user = getUser(req);
++++++			const settings = user.getSettingsOrDefaults();
++++++			const videoId = url.searchParams.get("v");
++++++			const continuation = url.searchParams.get("continuation");
++++++
++++++			if (!videoId || !continuation) {
++++++				return {
++++++					statusCode: 400,
++++++					contentType: "application/json",
++++++					content: JSON.stringify({error: "Missing videoId or continuation"})
++++++				};
++++++			}
++++++
++++++			const instanceOrigin = settings.local === 1 ? "http://localhost:3000" : settings.instance;
++++++
++++++			try {
++++++				const response = await request(`${instanceOrigin}/api/v1/comments/${videoId}?continuation=${encodeURIComponent(continuation)}`);
++++++				const data = await response.json();
++++++
++++++				return {
++++++					statusCode: 200,
++++++					contentType: "application/json",
++++++					content: JSON.stringify(data)
++++++				};
++++++			} catch (error) {
++++++				return {
++++++					statusCode: 500,
++++++					contentType: "application/json",
++++++					content: JSON.stringify({error: "Failed to fetch comments"})
++++++				};
++++++			}
++++++		}
+++++ 	}
+++++ ];
+++++\ No newline at end of file
+++++diff --git a/html/static/js/comments.js b/html/static/js/comments.js
+++++new file mode 100644
+++++index 0000000..5189537
+++++--- /dev/null
++++++++ b/html/static/js/comments.js
+++++@@ -0,0 +1,79 @@
++++++// Handle comment reply expansion
++++++document.querySelectorAll('.comment-reply-count').forEach(replyCountEl => {
++++++	replyCountEl.addEventListener('click', async (e) => {
++++++		e.preventDefault();
++++++		e.stopPropagation();
++++++
++++++		const continuation = replyCountEl.dataset.continuation;
++++++		const videoId = replyCountEl.dataset.videoId;
++++++		const commentItem = replyCountEl.closest('.comment-item');
++++++		const repliesContainer = commentItem.querySelector('.comment-replies-container');
++++++
++++++		// Toggle if already loaded
++++++		if (repliesContainer.style.display !== 'none') {
++++++			repliesContainer.style.display = 'none';
++++++			return;
++++++		}
++++++
++++++		// If already has content, just show it
++++++		if (repliesContainer.innerHTML) {
++++++			repliesContainer.style.display = 'block';
++++++			return;
++++++		}
++++++
++++++		// Set loading state
++++++		replyCountEl.textContent = 'Loading...';
++++++		replyCountEl.style.pointerEvents = 'none';
++++++		replyCountEl.style.opacity = '0.6';
++++++
++++++		try {
++++++			const response = await fetch(`/api/comments?v=${encodeURIComponent(videoId)}&continuation=${encodeURIComponent(continuation)}`);
++++++			const data = await response.json();
++++++
++++++			if (!data.comments || data.comments.length === 0) {
++++++				repliesContainer.innerHTML = '<div class="no-replies" style="padding: 12px; color: #999; font-size: 0.9em;">No replies available</div>';
++++++				repliesContainer.style.display = 'block';
++++++				return;
++++++			}
++++++
++++++			// Build HTML for replies
++++++			let repliesHTML = '<div class="nested-comments" style="margin-top: 12px; margin-left: 16px; padding-left: 12px; border-left: 2px solid #ccc;">';
++++++
++++++			data.comments.forEach(reply => {
++++++				repliesHTML += `
++++++					<div class="nested-comment-item" style="padding: 8px 0; border-bottom: 1px solid #f0f0f0;">
++++++						<div class="nested-comment-author-info" style="display: flex; gap: 8px; align-items: center; margin-bottom: 4px;">
++++++							<a href="${reply.authorUrl}" class="nested-comment-author" style="font-weight: bold; text-decoration: none; color: inherit;">${escapeHtml(reply.author)}</a>
++++++							${reply.verified ? '<span class="nested-comment-verified" style="color: #4a90e2; font-size: 0.9em;"></span>' : ''}
++++++							<span class="nested-comment-time" style="font-size: 0.85em; color: #666;">${reply.publishedText}</span>
++++++						</div>
++++++						<div class="nested-comment-text" style="margin: 4px 0; word-wrap: break-word; color: inherit;">${reply.contentHtml}</div>
++++++						${reply.likeCount ? `<div class="nested-comment-likes" style="font-size: 0.85em; color: #666; margin-top: 4px;"> ${reply.likeCount}</div>` : ''}
++++++					</div>
++++++				`;
++++++			});
++++++
++++++			repliesHTML += '</div>';
++++++			repliesContainer.innerHTML = repliesHTML;
++++++			repliesContainer.style.display = 'block';
++++++		} catch (err) {
++++++			console.error('Failed to load replies:', err);
++++++			repliesContainer.innerHTML = '<div class="error-replies" style="padding: 12px; color: #e74c3c; font-size: 0.9em;">Failed to load replies</div>';
++++++			repliesContainer.style.display = 'block';
++++++		} finally {
++++++			// Restore button state
++++++			const replyCount = parseInt(replyCountEl.dataset.replyCount) || 1;
++++++			const plural = replyCount === 1 ? 'reply' : 'replies';
++++++			replyCountEl.textContent = `${replyCount} ${plural}`;
++++++			replyCountEl.style.pointerEvents = 'auto';
++++++			replyCountEl.style.opacity = '1';
++++++		}
++++++	});
++++++});
++++++
++++++// Helper function to escape HTML
++++++function escapeHtml(text) {
++++++	const div = document.createElement('div');
++++++	div.textContent = text;
++++++	return div.innerHTML;
++++++}
+++++diff --git a/pug/video.pug b/pug/video.pug
+++++index 28b8416..11673af 100644
+++++--- a/pug/video.pug
++++++++ b/pug/video.pug
+++++@@ -82,7 +82,28 @@ block content
+++++ 
+++++         .description#description!= video.descriptionHtml
+++++ 
+++++-      //- Standard view
++++++        .comments-section
++++++          h2.comments-header Comments
++++++          if comments && comments.length
++++++            .comments-list
++++++              each comment in comments
++++++                .comment-item(data-comment-id=comment.commentId)
++++++                  .comment-author-info
++++++                    a(href=comment.authorUrl class="comment-author")= comment.author
++++++                    if comment.verified
++++++                      .comment-verified 
++++++                    .comment-time= comment.publishedText
++++++                  .comment-text!= comment.contentHtml
++++++                  .comment-footer
++++++                    if comment.likeCount
++++++                      .comment-likes
++++++                        |  #{comment.likeCount}
++++++                    if comment.replies && comment.replies.replyCount
++++++                      .comment-reply-count(data-continuation=comment.replies.continuation data-video-id=video.videoId data-reply-count=comment.replies.replyCount)= `${comment.replies.replyCount} ${comment.replies.replyCount === 1 ? 'reply' : 'replies'}`
++++++                  .comment-replies-container(style="display: none")
++++++          else
++++++            .no-comments Comments are disabled or unavailable for this video.
++++++      script(type="module" src=getStaticURL("html", "/static/js/comments.js"))
+++++       aside(style=continuous ? "display: none" : "")#standard-related-videos.related-videos
+++++         .related-cols
+++++           h2.related-header Related videos
+++++diff --git a/sass/includes/_video-page.sass b/sass/includes/_video-page.sass
+++++index 6774a83..abb68ee 100644
+++++--- a/sass/includes/_video-page.sass
++++++++ b/sass/includes/_video-page.sass
+++++@@ -197,3 +197,145 @@ $_theme: () !default
+++++ 
+++++ .fetch-status
+++++   white-space: pre-wrap
++++++
++++++// Comments
++++++
++++++.comments-section
++++++  margin-top: 32px
++++++  margin-bottom: 32px
++++++
++++++  .comments-header
++++++    font-size: 1.2em
++++++    font-weight: bold
++++++    margin-bottom: 16px
++++++    color: map.get($_theme, "text-0")
++++++
++++++  .comments-list
++++++    display: flex
++++++    flex-direction: column
++++++    gap: 16px
++++++
++++++  .comment-item
++++++    padding: 12px
++++++    border-left: 3px solid map.get($_theme, "edge-grey")
++++++    background-color: map.get($_theme, "bg-4")
++++++
++++++    .comment-author-info
++++++      display: flex
++++++      gap: 8px
++++++      margin-bottom: 8px
++++++      align-items: center
++++++
++++++      .comment-author
++++++        font-weight: bold
++++++        text-decoration: none
++++++        color: map.get($_theme, "text-0")
++++++
++++++        &:hover
++++++          text-decoration: underline
++++++
++++++      .comment-time
++++++        font-size: 0.85em
++++++        color: map.get($_theme, "text-1")
++++++
++++++  .comment-text
++++++    margin: 8px 0
++++++    word-wrap: break-word
++++++    color: map.get($_theme, "text-0")
++++++
++++++    a
++++++      color: map.get($_theme, "link-color")
++++++      text-decoration: none
++++++
++++++      &:hover
++++++        text-decoration: underline
++++++
++++++  .comment-likes
++++++    display: flex
++++++    align-items: center
++++++    gap: 4px
++++++    font-size: 0.9em
++++++    color: map.get($_theme, "text-1")
++++++
++++++    .like-icon
++++++      opacity: 0.7
++++++
++++++  .comment-footer
++++++    display: flex
++++++    gap: 16px
++++++    align-items: center
++++++    margin-top: 8px
++++++
++++++  .comment-reply-count
++++++    font-size: 0.9em
++++++    color: map.get($_theme, "text-1")
++++++    cursor: pointer
++++++    padding: 4px 8px
++++++    border-radius: 4px
++++++    transition: background-color 0.2s
++++++
++++++    &:hover
++++++      background-color: map.get($_theme, "bg-3")
++++++
++++++  .comment-verified
++++++    color: #4a90e2
++++++    font-size: 0.9em
++++++    margin-left: 4px
++++++
++++++  .comment-replies-container
++++++    margin-top: 12px
++++++    margin-left: 16px
++++++    padding-left: 12px
++++++    border-left: 2px solid map.get($_theme, "edge-grey")
++++++
++++++    .nested-comments
++++++      display: flex
++++++      flex-direction: column
++++++      gap: 8px
++++++
++++++    .nested-comment-item
++++++      padding: 8px 0
++++++      border-bottom: 1px solid map.get($_theme, "edge-grey")
++++++
++++++      &:last-child
++++++        border-bottom: none
++++++
++++++    .nested-comment-author-info
++++++      display: flex
++++++      gap: 8px
++++++      align-items: center
++++++      margin-bottom: 4px
++++++      font-size: 0.95em
++++++
++++++      .nested-comment-author
++++++        font-weight: bold
++++++        text-decoration: none
++++++        color: map.get($_theme, "text-0")
++++++
++++++        &:hover
++++++          text-decoration: underline
++++++
++++++      .nested-comment-verified
++++++        color: #4a90e2
++++++        font-size: 0.9em
++++++
++++++      .nested-comment-time
++++++        font-size: 0.85em
++++++        color: map.get($_theme, "text-1")
++++++
++++++    .nested-comment-text
++++++      margin: 4px 0
++++++      word-wrap: break-word
++++++      color: map.get($_theme, "text-0")
++++++      font-size: 0.95em
++++++
++++++    .nested-comment-likes
++++++      font-size: 0.85em
++++++      color: map.get($_theme, "text-1")
++++++      margin-top: 4px
++++++
++++++  .no-comments
++++++    padding: 20px
++++++    text-align: center
++++++    color: map.get($_theme, "text-1")
++++++    background-color: map.get($_theme, "bg-4")
+++++-- 
+++++2.52.0
+++++
++++diff --git a/patches/0031-cleanup.patch b/patches/0031-cleanup.patch
++++new file mode 100644
++++index 0000000..eccd53b
++++--- /dev/null
+++++++ b/patches/0031-cleanup.patch
++++@@ -0,0 +1,764 @@
+++++From 9c7303d6848e98c4ee3386f7a5b89825e008aea4 Mon Sep 17 00:00:00 2001
+++++From: Martin Kibera <martin.kibera.n@gmail.com>
+++++Date: Fri, 16 Jan 2026 13:45:23 +0300
+++++Subject: [PATCH 31/31] cleanup
+++++
+++++---
+++++ new.player.5 | 745 ---------------------------------------------------
+++++ 1 file changed, 745 deletions(-)
+++++ delete mode 100644 new.player.5
+++++
+++++diff --git a/new.player.5 b/new.player.5
+++++deleted file mode 100644
+++++index ded24c4..0000000
+++++--- a/new.player.5
++++++++ /dev/null
+++++@@ -1,745 +0,0 @@
+++++-import { q, qa, ElemJS } from "/static/js/elemjs/elemjs.js";
+++++-import { SubscribeButton } from "/static/js/modules/SubscribeButton.js";
+++++-
+++++-const videoElement = q("#video");
+++++-videoElement.setAttribute("fetchpriority", "low");
+++++-const audioElement = q("#audio");
+++++-// Buffer audio aggressively
+++++-audioElement.setAttribute("fetchpriority", "high");
+++++-audioElement.preload = "auto";
+++++-
+++++-// Make video focusable
+++++-videoElement.setAttribute("tabindex", "0");
+++++-
+++++-let userInteracted = false;
+++++-document.addEventListener("click", () => { userInteracted = true; alignStreams(); }, { once: true });
+++++-
+++++-let syncCheckInterval = null;
+++++-const videoFormats = new Map();
+++++-const audioFormats = [];
+++++-
+++++-[...data.formatStreams, ...data.adaptiveFormats].forEach(f => {
+++++-    f.isAdaptive = f.type.startsWith("video");
+++++-    if (f.type.startsWith("video")) {
+++++-        videoFormats.set(f.itag, f);
+++++-    } else {
+++++-        audioFormats.push(f);
+++++-    }
+++++-});
+++++-
+++++-// --- pre-warm all known origins ---
+++++-videoFormats.forEach(vf => warmup(vf.url));
+++++-audioFormats.forEach(af => warmup(af.url));
+++++-
+++++-// Update src from initial url page load
+++++-try {
+++++-    const src = videoElement.querySelector('source')?.src
+++++-    const itag = videoElement.dataset.itag
+++++-    const vf = itag && videoFormats.get(itag)
+++++-    if (vf && src) vf.url = src
+++++-} catch {}
+++++-
+++++-function getBestAudioFormat() {
+++++-    function parseXtags(url) {
+++++-        const urlParams = new URLSearchParams(url.split('?')[1] ?? '');
+++++-        const xtags = urlParams.get('xtags') ?? '';
+++++-        const parts = xtags.split(':');
+++++-        let language = 'unknown';
+++++-        let content = 'unknown';
+++++-        for (const part of parts) {
+++++-            if (part.startsWith('lang=')) {
+++++-                language = part.replace('lang=', '');
+++++-                if (language.includes('-')) language = language.split('-')[0];
+++++-            }
+++++-            if (part.startsWith('acont=')) content = part.replace('acont=', '');
+++++-        }
+++++-        return { language, content };
+++++-    }
+++++-
+++++-    let best = null;
+++++-
+++++-    for (const f of audioFormats) {
+++++-        if (!isValidUrl(f.url)) continue;
+++++-        const { language, content } = parseXtags(f.url);
+++++-        if (language === 'en' && content === 'original') {
+++++-            if (!best || f.bitrate > best.bitrate) {
+++++-                best = f;
+++++-            }
+++++-        }
+++++-    }
+++++-
+++++-    if (!best) {
+++++-        for (const f of audioFormats) {
+++++-            if (!isValidUrl(f.url)) continue;
+++++-            const { language } = parseXtags(f.url);
+++++-            if (language === 'en') {
+++++-                if (!best || f.bitrate > best.bitrate) {
+++++-                    best = f;
+++++-                }
+++++-            }
+++++-        }
+++++-    }
+++++-
+++++-    if (!best) {
+++++-        for (const f of audioFormats) {
+++++-            if (!isValidUrl(f.url)) continue;
+++++-            if (!best || f.bitrate > best.bitrate) {
+++++-                best = f;
+++++-            }
+++++-        }
+++++-    }
+++++-
+++++-    return best;
+++++-}
+++++-
+++++-function isValidUrl(string) {
+++++-    try {
+++++-        new URL(string);
+++++-        return true;
+++++-    } catch (_) {
+++++-        return false;
+++++-    }
+++++-}
+++++-
+++++-const warmedOrigins = new Set();
+++++-
+++++-function warmup(url) {
+++++-    try {
+++++-        const origin = new URL(url).origin;
+++++-        if (warmedOrigins.has(origin)) return; // already done
+++++-        warmedOrigins.add(origin);
+++++-
+++++-        // Preconnect: TCP + TLS
+++++-        const preconnectLink = document.createElement("link");
+++++-        preconnectLink.rel = "preconnect";
+++++-        preconnectLink.href = origin;
+++++-        document.head.appendChild(preconnectLink);
+++++-
+++++-        // DNS prefetch
+++++-        const dnsLink = document.createElement("link");
+++++-        dnsLink.rel = "dns-prefetch";
+++++-        dnsLink.href = origin;
+++++-        document.head.appendChild(dnsLink);
+++++-
+++++-    } catch {}
+++++-}
+++++-
+++++-function loadMediaWithRetry(mediaElement, url, retries = 6) {
+++++-    let attempt = 0;
+++++-    let locked = false;
+++++-
+++++-    function tryLoad() {
+++++-        // warm up connection BEFORE requesting the media
+++++-        warmup(url);
+++++-
+++++-        mediaElement.src = url;
+++++-        mediaElement.load();
+++++-
+++++-        mediaElement.onplaying = () => { locked = true; };
+++++-        mediaElement.oncanplay = () => { locked = true; };
+++++-
+++++-        mediaElement.onerror = () => {
+++++-            if (locked) return;
+++++-            attempt++;
+++++-            console.error("Media load failed:", url);
+++++-
+++++-            if (attempt < retries) {
+++++-                setTimeout(tryLoad, 1000 * attempt); // gradual backoff, same logic, faster start
+++++-            } else {
+++++-                console.error("Failed to load media after", retries, "attempts.");
+++++-            }
+++++-        };
+++++-    }
+++++-
+++++-    tryLoad();
+++++-}
+++++-
+++++-function alignStreams() {
+++++-    if (!audioElement.src || !videoElement.src) return;
+++++-    const t = Math.max(audioElement.currentTime || 0, videoElement.currentTime || 0);
+++++-    audioElement.currentTime = t;
+++++-    videoElement.currentTime = t;
+++++-}
+++++-
+++++-
+++++-let pipReady = false;
+++++-
+++++-document.addEventListener("visibilitychange", async () => {
+++++-    const video = document.querySelector("video");
+++++-    if (!video || !document.pictureInPictureEnabled) return;
+++++-
+++++-    if (document.hidden && !document.pictureInPictureElement && !video.paused) {
+++++-        if (!pipReady) {
+++++-            console.warn("PiP blocked. Waiting for user gesture to enable re-entry.");
+++++-            return;
+++++-        }
+++++-
+++++-        try {
+++++-            await video.requestPictureInPicture();
+++++-        } catch (err) {
+++++-            console.error("PiP request failed:", err);
+++++-        }
+++++-    }
+++++-});
+++++-
+++++-document.addEventListener("leavepictureinpicture", () => {
+++++-    pipReady = false;
+++++-});
+++++-
+++++-document.addEventListener("click", () => {
+++++-    pipReady = true;
+++++-});
+++++-
+++++-const audioContext = new AudioContext();
+++++-
+++++-class FormatLoader {
+++++-    constructor() {
+++++-        this.npv = videoFormats.get(videoElement.getAttribute("data-itag"));
+++++-        this.npa = null;
+++++-
+++++-        // --- FIX: attach best audio on initial load if video has no audio ---
+++++-        const hasAudio = this.npv.type && (this.npv.type.includes("mp4a") || this.npv.type.includes("audio"));
+++++-        if (!hasAudio) {
+++++-            const bestAudio = getBestAudioFormat();
+++++-            if (bestAudio) {
+++++-                this.npa = bestAudio;
+++++-            }
+++++-        }
+++++-
+++++-        // Load media immediately
+++++-        requestAnimationFrame(() => this.update());
+++++-    }
+++++-
+++++-    play(itag, isQualitySwitch = false) {
+++++-        this.npv = videoFormats.get(itag);
+++++-        this.npa = null;
+++++-
+++++-        const hasAudio = this.npv.type && (this.npv.type.includes("mp4a") || this.npv.type.includes("audio"));
+++++-        if (!hasAudio) {
+++++-            const bestAudio = getBestAudioFormat();
+++++-            if (bestAudio && bestAudio.url !== this.npv.url) {
+++++-                this.npa = bestAudio;
+++++-            }
+++++-        }
+++++-
+++++-        this.update(isQualitySwitch);
+++++-    }
+++++-
+++++-    update(isQualitySwitch = false) {
+++++-        if (!userInteracted) return;
+++++-        cleanupSync();
+++++-
+++++-        const lastTime = isQualitySwitch ? videoElement.currentTime : null;
+++++-
+++++-        if (!this.npv.url) {
+++++-            console.error("No URL for video format! Cannot load.");
+++++-            return;
+++++-        }
+++++-
+++++-        if (isQualitySwitch) {
+++++-            videoElement.pause();
+++++-            stopSyncCheck();
+++++-
+++++-            let videoReady = false;
+++++-            let audioReady = false;
+++++-
+++++-            const tryResume = () => {
+++++-                if (videoReady && (audioReady || !this.npa)) {
+++++-                    if (lastTime !== null) videoElement.currentTime = lastTime;
+++++-                    videoElement.play().catch(() => {});
+++++-
+++++-                    if (this.npa) {
+++++-                        if (lastTime !== null) audioElement.currentTime = lastTime;
+++++-                        audioElement.play().catch(() => {});
+++++-                    }
+++++-
+++++-                    startSyncCheck();
+++++-                }
+++++-            };
+++++-
+++++-            videoElement.src = this.npv.url;
+++++-            videoElement.load();
+++++-            videoElement.addEventListener('canplaythrough', () => {
+++++-                videoReady = true;
+++++-                tryResume();
+++++-            }, { once: true });
+++++-
+++++-            if (this.npa) {
+++++-                audioElement.src = this.npa.url;
+++++-                audioElement.load();
+++++-                audioElement.addEventListener('canplaythrough', () => {
+++++-                    audioReady = true;
+++++-                    tryResume();
+++++-                }, { once: true });
+++++-            } else {
+++++-                audioElement.pause();
+++++-                audioElement.removeAttribute("src");
+++++-                audioReady = true;
+++++-            }
+++++-
+++++-        } else {
+++++-            loadMediaWithRetry(videoElement, this.npv.url);
+++++-
+++++-            if (this.npa) loadMediaWithRetry(audioElement, this.npa.url);
+++++-            else {
+++++-                audioElement.pause();
+++++-                audioElement.removeAttribute("src");
+++++-            }
+++++-        }
+++++-    }
+++++-}
+++++-
+++++-const formatLoader = new FormatLoader();
+++++-
+++++-if (formatLoader.npa?.url) {
+++++-    audioElement.src = formatLoader.npa.url;
+++++-    audioElement.load();
+++++-}
+++++-
+++++-class PlayManager {
+++++-    constructor(media, isAudio) {
+++++-        this.media = media;
+++++-        this.isAudio = isAudio;
+++++-    }
+++++-
+++++-    isActive() {
+++++-        return !this.isAudio || formatLoader.npa;
+++++-    }
+++++-
+++++-    play() {
+++++-        if (this.isActive()) this.media.play();
+++++-    }
+++++-
+++++-    pause() {
+++++-        if (this.isActive()) this.media.pause();
+++++-    }
+++++-}
+++++-
+++++-const playManagers = {
+++++-    video: new PlayManager(videoElement, false),
+++++-    audio: new PlayManager(audioElement, true)
+++++-};
+++++-
+++++-class QualitySelect extends ElemJS {
+++++-    constructor() {
+++++-        super(q("#quality-select"));
+++++-        this.initialized = false;
+++++-
+++++-        // Defer until DOM & videoFormats ready
+++++-        requestAnimationFrame(() => {
+++++-            const saved = localStorage.getItem("lastQuality");
+++++-
+++++-            // Only set value if the option exists
+++++-            if (saved && this.element.querySelector(`option[value="${saved}"]`)) {
+++++-                this.element.value = saved;
+++++-
+++++-                if (videoElement.readyState >= 1) {
+++++-                    formatLoader.play(saved, true);
+++++-                } else {
+++++-                    videoElement.addEventListener("loadedmetadata", () => {
+++++-                        formatLoader.play(saved, true);
+++++-                    }, { once: true });
+++++-                }
+++++-            }
+++++-
+++++-            this.initialized = true;
+++++-        });
+++++-
+++++-        this.on("input", this.setFormat.bind(this));
+++++-    }
+++++-
+++++-    setFormat() {
+++++-        if (!this.initialized) return;
+++++-
+++++-        const itag = this.element.value;
+++++-        localStorage.setItem("lastQuality", itag);
+++++-
+++++-        formatLoader.play(itag, true);
+++++-        videoElement.focus();
+++++-    }
+++++-}
+++++-
+++++-new QualitySelect();
+++++-
+++++-const ignoreNext = { play: 0 };
+++++-
+++++-function startSyncCheck() {
+++++-    if (syncCheckInterval) clearInterval(syncCheckInterval);
+++++-
+++++-    // Only start syncing if audio is ready or theres no separate audio
+++++-    if (formatLoader.npa && audioElement.readyState < 2) {
+++++-        audioElement.addEventListener('canplaythrough', startSyncCheck, { once: true });
+++++-        return;
+++++-    }
+++++-
+++++-    syncCheckInterval = setInterval(() => {
+++++-        if (!videoElement.paused && !audioElement.paused) {
+++++-            const drift = Math.abs(videoElement.currentTime - audioElement.currentTime);
+++++-            if (drift > 0.1) {
+++++-                audioElement.currentTime = videoElement.currentTime;
+++++-            }
+++++-        }
+++++-    }, 1000);
+++++-}
+++++-
+++++-function stopSyncCheck() {
+++++-    if (syncCheckInterval) clearInterval(syncCheckInterval);
+++++-    syncCheckInterval = null;
+++++-}
+++++-
+++++-function cleanupSync() {
+++++-    stopSyncCheck();
+++++-}
+++++-
+++++-videoElement.addEventListener("play", startSyncCheck);
+++++-videoElement.addEventListener("pause", stopSyncCheck);
+++++-
+++++-function playbackIntervention(event) {
+++++-    const target = event.target;
+++++-    const other = target === videoElement ? audioElement : videoElement;
+++++-
+++++-    // Prevent race while media is buffering or not ready
+++++-    if (target.readyState < 2) return;
+++++-
+++++-    // Only sync audio for non-SB manual seeks
+++++-    if (audioElement.src && !ignoreNext[event.type]--) {
+++++-        if (event.type === "seeked") {
+++++-            const targetTime = target.currentTime;
+++++-            other.currentTime = targetTime;
+++++-
+++++-            setTimeout(() => {
+++++-                if (Math.abs(videoElement.currentTime - audioElement.currentTime) > 0.1) {
+++++-                    videoElement.currentTime = targetTime;
+++++-                    audioElement.currentTime = targetTime;
+++++-                }
+++++-            }, 100);
+++++-        } else if (event.type === "play") {
+++++-            if (other.readyState >= 2) {
+++++-                playManagers[other.tagName.toLowerCase()].play();
+++++-            }
+++++-        } else if (event.type === "pause") {
+++++-            other.pause();
+++++-        } else if (event.type === "ratechange") {
+++++-            other.playbackRate = target.playbackRate;
+++++-        }
+++++-    }
+++++-}
+++++-
+++++-function debounce(func, wait) {
+++++-    let timeoutId;
+++++-    return (...args) => {
+++++-        clearTimeout(timeoutId);
+++++-        timeoutId = setTimeout(() => func(...args), wait);
+++++-    };
+++++-}
+++++-
+++++-const debouncedPlaybackIntervention = debounce(playbackIntervention, 100);
+++++-["pause", "play", "seeked"].forEach(eventName =>
+++++-    videoElement.addEventListener(eventName, debouncedPlaybackIntervention)
+++++-);
+++++-["canplaythrough", "waiting", "stalled", "ratechange"].forEach(eventName => {
+++++-    videoElement.addEventListener(eventName, playbackIntervention);
+++++-    audioElement.addEventListener(eventName, playbackIntervention);
+++++-});
+++++-
+++++-// Error handling
+++++-videoElement.addEventListener("error", (e) => {
+++++-    console.error("Video loading error:", e);
+++++-});
+++++-audioElement.addEventListener("error", (e) => {
+++++-    console.error("Audio loading error:", e);
+++++-});
+++++-
+++++-// Loading feedback
+++++-videoElement.addEventListener("waiting", () => console.log("Video buffering..."));
+++++-audioElement.addEventListener("waiting", () => console.log("Audio buffering..."));
+++++-
+++++-// Fix reverb on buffering mid-playback
+++++-// --- Robust mid-playback buffering isolation ---
+++++-let wasPlayingBeforeBuffer = false;
+++++-
+++++-videoElement.addEventListener("waiting", () => {
+++++-    if (!videoElement.paused && videoElement.currentTime > 0) {
+++++-        wasPlayingBeforeBuffer = true;
+++++-
+++++-        if (!audioElement.paused && formatLoader.npa) {
+++++-            audioElement.muted = true;
+++++-        }
+++++-    }
+++++-});
+++++-
+++++-videoElement.addEventListener("playing", () => {
+++++-    if (wasPlayingBeforeBuffer && formatLoader.npa) {
+++++-        wasPlayingBeforeBuffer = false;
+++++-        audioElement.muted = false;
+++++-        audioElement.currentTime = videoElement.currentTime;
+++++-    }
+++++-});
+++++-
+++++-// --- Robust smooth seek for separate audio/video ---
+++++-let freezePlayback = false
+++++-let shouldResume = false
+++++-
+++++-videoElement.addEventListener("seeking", () => {
+++++-    // --- New: delay video naturally if audio is ahead ---
+++++-    if (formatLoader.npa) {
+++++-        const targetTime = videoElement.currentTime;
+++++-
+++++-        const waitAudio = () => {
+++++-            if (audioElement.buffered.length > 0) {
+++++-                // Find the buffered range containing targetTime
+++++-                let start = audioElement.buffered.start(0);
+++++-                for (let i = 0; i < audioElement.buffered.length; i++) {
+++++-                    if (audioElement.buffered.start(i) <= targetTime && audioElement.buffered.end(i) >= targetTime) {
+++++-                        start = audioElement.buffered.start(i);
+++++-                        break;
+++++-                    }
+++++-                }
+++++-
+++++-                if (videoElement.currentTime < start) videoElement.currentTime = start;
+++++-            } else {
+++++-                requestAnimationFrame(waitAudio);
+++++-            }
+++++-        };
+++++-
+++++-        requestAnimationFrame(waitAudio);
+++++-    }
+++++-
+++++-    // --- Existing freezePlayback logic remains untouched ---
+++++-    freezePlayback = true;
+++++-    if (!videoElement.paused || (formatLoader.npa && !audioElement.paused)) {
+++++-        shouldResume = true;
+++++-        videoElement.pause()
+++++-        if (formatLoader.npa) audioElement.pause()
+++++-    }
+++++-});
+++++-
+++++-function resumeWhenBuffered() {
+++++-    if (!freezePlayback || !shouldResume) return;
+++++-
+++++-    if (videoElement.readyState >= 2 && (!formatLoader.npa || audioElement.readyState >= 2)) {
+++++-        freezePlayback = false
+++++-        shouldResume = false
+++++-        const t = videoElement.currentTime
+++++-        if (formatLoader.npa) audioElement.currentTime = t
+++++-        videoElement.play().catch(()=>{})
+++++-        if (formatLoader.npa) audioElement.play().catch(()=>{})
+++++-    } else {
+++++-        requestAnimationFrame(resumeWhenBuffered)
+++++-    }
+++++-}
+++++-
+++++-videoElement.addEventListener("seeking", () => {
+++++-    requestAnimationFrame(resumeWhenBuffered)
+++++-})
+++++-
+++++-
+++++-const videoObserver = new IntersectionObserver((entries) => {
+++++-    entries.forEach(entry => {
+++++-        if (entry.isIntersecting) {
+++++-            loadMediaWithRetry(videoElement, formatLoader.npv.url);
+++++-            if (formatLoader.npa) {
+++++-                loadMediaWithRetry(audioElement, formatLoader.npa.url);
+++++-            }
+++++-            videoObserver.disconnect();
+++++-        }
+++++-    });
+++++-}, { threshold: 0.5 });
+++++-
+++++-videoObserver.observe(videoElement);
+++++-
+++++-function relativeSeek(seconds) {
+++++-    const t = videoElement.currentTime + seconds;
+++++-    videoElement.currentTime = t;
+++++-    if (formatLoader.npa) audioElement.currentTime = t;
+++++-}
+++++-
+++++-async function playVideo() {
+++++-    if (!userInteracted) return;
+++++-    if (!videoElement.paused) return;
+++++-
+++++-    const targetTime = videoElement.currentTime;
+++++-    audioElement.currentTime = targetTime;
+++++-    ignoreNext.play = 2;
+++++-
+++++-    try {
+++++-        if (audioContext.state === 'suspended') await audioContext.resume();
+++++-
+++++-        // Only play video immediately if no separate audio, otherwise wait for audio
+++++-        if (!formatLoader.npa) {
+++++-            await videoElement.play();
+++++-        } else {
+++++-            // Wait until audio can play
+++++-            if (audioElement.readyState >= 2) {
+++++-                await audioElement.play();
+++++-                await videoElement.play();
+++++-            } else {
+++++-                audioElement.addEventListener('canplaythrough', async () => {
+++++-                    await audioElement.play();
+++++-                    await videoElement.play();
+++++-                }, { once: true });
+++++-            }
+++++-        }
+++++-    } catch (e) {
+++++-        console.error("Playback failed:", e);
+++++-    }
+++++-}
+++++-
+++++-function togglePlaying() {
+++++-    if (videoElement.paused) {
+++++-        if (!userInteracted) return;
+++++-        playVideo();
+++++-    } else {
+++++-        videoElement.pause();
+++++-        if (formatLoader.npa) audioElement.pause(); // also pause separate audio
+++++-    }
+++++-}
+++++-
+++++-function toggleFullScreen() {
+++++-    if (document.fullscreenElement || document.webkitFullscreenElement) {
+++++-        (document.exitFullscreen || document.webkitExitFullscreen).call(document);
+++++-    } else {
+++++-        (videoElement.requestFullscreen || videoElement.webkitRequestFullscreen).call(videoElement);
+++++-    }
+++++-}
+++++-
+++++-//  Critical: Track interaction and refocus
+++++-videoElement.addEventListener("pointerdown", () => {
+++++-    userInteracted = true
+++++-    videoElement.focus();
+++++-});
+++++-
+++++-videoElement.addEventListener("click", (event) => {
+++++-    event.preventDefault();
+++++-    togglePlaying();
+++++-    videoElement.lastInteraction = Date.now(); // Track last click
+++++-    videoElement.focus();
+++++-});
+++++-
+++++-videoElement.addEventListener("seeking", () => {
+++++-    freezePlayback = true;
+++++-    if (formatLoader.npa && !videoElement.paused) {
+++++-        shouldResume = true;
+++++-        videoElement.pause();
+++++-        audioElement.pause();
+++++-    }
+++++-});
+++++-
+++++-//  Capture spacebar early and forcefully
+++++-const keyActions = new Map([
+++++-    ["j", () => relativeSeek(-10)],
+++++-    ["n", () => relativeSeek(-10)],
+++++-    ["k", togglePlaying],
+++++-    ["p", togglePlaying],
+++++-    [" ", togglePlaying],
+++++-    ["e", togglePlaying],
+++++-    ["l", () => relativeSeek(10)],
+++++-    ["o", () => relativeSeek(10)],
+++++-    ["ArrowLeft", () => relativeSeek(-5)],
+++++-    ["ArrowRight", () => relativeSeek(5)],
+++++-    ["f", toggleFullScreen]
+++++-]);
+++++-
+++++-// Use capture phase to intercept spacebar before browser scrolls
+++++-document.addEventListener("keydown", async (event) => {
+++++-    // Ignore inputs and Ctrl combinations
+++++-    if (["INPUT", "SELECT", "TEXTAREA", "BUTTON"].includes(event.target.tagName) || event.ctrlKey) {
+++++-        return;
+++++-    }
+++++-
+++++-    if (event.key === "k") {
+++++-        event.preventDefault();
+++++-
+++++-        // Track last interaction so other logic (like spacebar) sees a gesture
+++++-        videoElement.lastInteraction = Date.now();
+++++-
+++++-        // Attempt to play video and audio
+++++-        try {
+++++-            if (videoElement.paused) {
+++++-                await videoElement.play(); // counts as user gesture
+++++-                if (audioElement.src && playManagers.audio.isActive()) {
+++++-                    try {
+++++-                        await audioElement.play();
+++++-                    } catch (e) {
+++++-                        console.warn("Audio blocked until user gesture:", e);
+++++-                    }
+++++-                }
+++++-            } else {
+++++-                videoElement.pause();
+++++-                audioElement.pause();
+++++-            }
+++++-        } catch (e) {
+++++-            console.warn("Playback blocked by browser:", e);
+++++-        }
+++++-
+++++-        return; // prevent further handling
+++++-    }
+++++-
+++++-    const action = keyActions.get(event.key);
+++++-    if (action) {
+++++-        if (event.key === " ") {
+++++-            const isActive = document.activeElement === videoElement;
+++++-            const recentlyClicked = Date.now() - (videoElement.lastInteraction || 0) < 15000;
+++++-            if (!isActive && !recentlyClicked) return;
+++++-            event.preventDefault();
+++++-        }
+++++-
+++++-        action();
+++++-        event.preventDefault();
+++++-    }
+++++-}, true); // capture phase: critical for gesture detection
+++++-
+++++-
+++++-if ('mediaSession' in navigator) {
+++++-    navigator.mediaSession.metadata = new MediaMetadata({
+++++-        title: 'Video Title',
+++++-        artist: 'Artist Name',
+++++-        album: 'Album Name',
+++++-    });
+++++-
+++++-    navigator.mediaSession.setActionHandler('play', togglePlaying);
+++++-    navigator.mediaSession.setActionHandler('pause', togglePlaying);
+++++-}
+++++-
+++++-videoElement.setAttribute('preload', 'metadata');
+++++-audioElement.setAttribute('preload', 'metadata');
+++++-
+++++-new SubscribeButton(q("#subscribe"));
+++++-
+++++-let userSeeking = false;
+++++-
+++++-document.addEventListener('click', (event) => {
+++++-    const timestampEl = event.target.closest('[data-clickable-timestamp]');
+++++-    if (!timestampEl) return;
+++++-
+++++-    event.preventDefault();
+++++-    const time = parseFloat(timestampEl.getAttribute('data-clickable-timestamp'));
+++++-    if (isNaN(time)) return;
+++++-
+++++-    userSeeking = true;
+++++-
+++++-    // Set times
+++++-    videoElement.currentTime = time;
+++++-
+++++-    if (formatLoader.npa?.url) {
+++++-        audioElement.src = formatLoader.npa.url;
+++++-        audioElement.load();
+++++-        audioElement.currentTime = time;
+++++-
+++++-        // --- Natural delay: video cannot render past buffered audio ---
+++++-        const waitForAudioBuffer = () => {
+++++-            if (audioElement.buffered.length > 0) {
+++++-                const start = audioElement.buffered.start(0);
+++++-                if (videoElement.currentTime < start) videoElement.currentTime = start;
+++++-            } else {
+++++-                requestAnimationFrame(waitForAudioBuffer);
+++++-            }
+++++-        };
+++++-        requestAnimationFrame(waitForAudioBuffer);
+++++-    }
+++++-
+++++-    window.history.replaceState(null, '', timestampEl.href);
+++++-
+++++-    videoElement.addEventListener('seeked', () =>
+++++-        setTimeout(() => userSeeking = false, 300), { once: true });
+++++-});
+++++-- 
+++++2.52.0
+++++
++++-- 
++++2.52.0
++++
+++diff --git a/patches/0033-update-README.patch b/patches/0033-update-README.patch
+++new file mode 100644
+++index 0000000..8b3b1c8
+++--- /dev/null
++++++ b/patches/0033-update-README.patch
+++@@ -0,0 +1,47 @@
++++From 20afc07b769d0ada0f45cca8533d14eb200bddbd Mon Sep 17 00:00:00 2001
++++From: Martin Kibera <martin.kibera.n@gmail.com>
++++Date: Fri, 16 Jan 2026 17:58:35 +0300
++++Subject: [PATCH] update README
++++
++++---
++++ README.md | 23 +++++++++++++++++++++++
++++ 1 file changed, 23 insertions(+)
++++
++++diff --git a/README.md b/README.md
++++index 2154606..2b63a9e 100644
++++--- a/README.md
+++++++ b/README.md
++++@@ -1,3 +1,24 @@
+++++# A fork of Cloudtube
+++++
+++++This is how I watch Youtube. Clean UI. No ads.
+++++
+++++Features added:
+++++- Smooth media playback. (DASH makes this hard but current implementation is usable).
+++++- Media fetching retry with backoff.
+++++- Auto picture-in-picture when user leaves page mid-playback.
+++++- 720p setting selects correct video quality.
+++++- English audio is always preferred, including videos with dubbed audio.
+++++- Timestamp jump fixes.
+++++- Uses MediaSession API for external media control.
+++++- Comments from invidious API.
+++++
+++++Notes:
+++++- Requires a WORKING invidious instance.
+++++- Media playback on Firefox no good (as of Jan 2026).
+++++
+++++<details>
+++++<summary>Show Original README</summary>
+++++
++++ # CloudTube
++++ 
++++ ## Navigation
++++@@ -19,3 +40,5 @@
++++ [todo]: https://todo.sr.ht/~cadence/tube
++++ [matrix]: https://matrix.to/#/#cloudtube:cadence.moe
++++ [docs]: https://git.sr.ht/~cadence/tube-docs
+++++
+++++</details>
++++-- 
++++2.52.0
++++
+++diff --git a/patches/0034-buffer-audio-by-at-least-3s.patch b/patches/0034-buffer-audio-by-at-least-3s.patch
+++new file mode 100644
+++index 0000000..995b096
+++--- /dev/null
++++++ b/patches/0034-buffer-audio-by-at-least-3s.patch
+++@@ -0,0 +1,30 @@
++++From 7d1b9002030a3f2ec55ac73d802af26b59130029 Mon Sep 17 00:00:00 2001
++++From: Martin Kibera <martin.kibera.n@gmail.com>
++++Date: Fri, 16 Jan 2026 21:53:20 +0300
++++Subject: [PATCH] buffer audio by at least 3s
++++
++++---
++++ html/static/js/player.js | 7 ++++++-
++++ 1 file changed, 6 insertions(+), 1 deletion(-)
++++
++++diff --git a/html/static/js/player.js b/html/static/js/player.js
++++index 78bcafe..ad87e89 100644
++++--- a/html/static/js/player.js
+++++++ b/html/static/js/player.js
++++@@ -439,7 +439,12 @@ async function waitForAudioThenPlay(videoEl, audioEl) {
++++         if (audioEl.buffered.length > 0) return resolve();
++++ 
++++         const check = () => {
++++-            if (audioEl.buffered.length > 0) return resolve();
+++++            if (audioEl.buffered.length > 0) {
+++++                const audioEnd = audioEl.buffered.end(audioEl.buffered.length - 1);
+++++                if (audioEnd - videoEl.currentTime >= 3) {
+++++                    return resolve();
+++++                }
+++++            }
++++             requestAnimationFrame(check);
++++         };
++++         requestAnimationFrame(check);
++++-- 
++++2.52.0
++++
+++diff --git a/patches/0035-handle-exception-from-comments-fetch.patch b/patches/0035-handle-exception-from-comments-fetch.patch
+++new file mode 100644
+++index 0000000..81f001c
+++--- /dev/null
++++++ b/patches/0035-handle-exception-from-comments-fetch.patch
+++@@ -0,0 +1,31 @@
++++From bd3d181eefea9c00ae6ffdb0844e62dabdefcd2e Mon Sep 17 00:00:00 2001
++++From: Martin Kibera <martin.kibera.n@gmail.com>
++++Date: Fri, 16 Jan 2026 22:05:00 +0300
++++Subject: [PATCH] handle exception from comments fetch
++++
++++---
++++ api/video.js | 8 +++++++-
++++ 1 file changed, 7 insertions(+), 1 deletion(-)
++++
++++diff --git a/api/video.js b/api/video.js
++++index 1457579..1956955 100644
++++--- a/api/video.js
+++++++ b/api/video.js
++++@@ -126,7 +126,13 @@ module.exports = [
++++ 				? request(`${instanceOrigin}/api/v1/videos/${id}`).then(res => res.json())
++++ 				: JSON.parse(new URLSearchParams(body.toString()).get("video"));
++++ 
++++-			const commentsFuture = request(`${instanceOrigin}/api/v1/comments/${id}`).then(res => res.json());
+++++			const commentsFuture = request(`${instanceOrigin}/api/v1/comments/${id}`)
+++++				.then(res => res.json())
+++++				.catch(err => {
+++++					console.error("Comments fetch failed:", err.code || err.message);
+++++					return {comments: []};
+++++				});
+++++
++++ 
++++ 			try {
++++ 				const video = await videoFuture;
++++-- 
++++2.52.0
++++
+++diff --git a/patches/0036-fix-non-resume-after-seek-issue.patch b/patches/0036-fix-non-resume-after-seek-issue.patch
+++new file mode 100644
+++index 0000000..48c1d6f
+++--- /dev/null
++++++ b/patches/0036-fix-non-resume-after-seek-issue.patch
+++@@ -0,0 +1,50 @@
++++From a678de8fb45f6e1eca03a75812906d256a3e439b Mon Sep 17 00:00:00 2001
++++From: Martin Kibera <martin.kibera.n@gmail.com>
++++Date: Fri, 16 Jan 2026 23:31:32 +0300
++++Subject: [PATCH] fix non-resume after seek issue
++++
++++---
++++ html/static/js/player.js | 17 ++++++++++++-----
++++ 1 file changed, 12 insertions(+), 5 deletions(-)
++++
++++diff --git a/html/static/js/player.js b/html/static/js/player.js
++++index ad87e89..ad24b52 100644
++++--- a/html/static/js/player.js
+++++++ b/html/static/js/player.js
++++@@ -530,21 +530,28 @@ let freezePlayback = false
++++ let shouldResume = false
++++ 
++++ videoElement.addEventListener("seeking", async (event) => {
++++-    // --- New: delay video naturally if audio is ahead ---
++++     if (formatLoader.npa) {
++++         const targetTime = videoElement.currentTime;
+++++
+++++        // Let waitForAudioThenPlay handle pausing/resuming
++++         await waitForAudioThenPlay(videoElement, audioElement);
+++++
+++++        // Clear freeze flags immediately after waiting
+++++        freezePlayback = false;
+++++        shouldResume = false;
+++++
+++++        return; // skip old pause logic
++++     }
++++ 
++++-    // --- Existing freezePlayback logic remains untouched ---
+++++    // Fallback for no separate audio
++++     freezePlayback = true;
++++-    if (!videoElement.paused || (formatLoader.npa && !audioElement.paused)) {
+++++    if (!videoElement.paused) {
++++         shouldResume = true;
++++-        videoElement.pause()
++++-        if (formatLoader.npa) audioElement.pause()
+++++        videoElement.pause();
++++     }
++++ });
++++ 
+++++
++++ function resumeWhenBuffered() {
++++     if (!freezePlayback || !shouldResume) return;
++++ 
++++-- 
++++2.52.0
++++
+++diff --git a/patches/0037-remove-debug-log-from-comment-fetch-exception.patch b/patches/0037-remove-debug-log-from-comment-fetch-exception.patch
+++new file mode 100644
+++index 0000000..f58e3ce
+++--- /dev/null
++++++ b/patches/0037-remove-debug-log-from-comment-fetch-exception.patch
+++@@ -0,0 +1,29 @@
++++From dac761a8f845d52292f3dd1f7beda0120660c183 Mon Sep 17 00:00:00 2001
++++From: Martin Kibera <martin.kibera.n@gmail.com>
++++Date: Fri, 16 Jan 2026 23:45:33 +0300
++++Subject: [PATCH] remove debug log from comment fetch exception
++++
++++---
++++ api/video.js | 6 +-----
++++ 1 file changed, 1 insertion(+), 5 deletions(-)
++++
++++diff --git a/api/video.js b/api/video.js
++++index 1956955..bf67eb1 100644
++++--- a/api/video.js
+++++++ b/api/video.js
++++@@ -128,11 +128,7 @@ module.exports = [
++++ 
++++ 			const commentsFuture = request(`${instanceOrigin}/api/v1/comments/${id}`)
++++ 				.then(res => res.json())
++++-				.catch(err => {
++++-					console.error("Comments fetch failed:", err.code || err.message);
++++-					return {comments: []};
++++-				});
++++-
+++++				.catch(() => ({ comments: [] }));
++++ 
++++ 			try {
++++ 				const video = await videoFuture;
++++-- 
++++2.52.0
++++
+++diff --git a/scripts/sync-patches.sh b/scripts/sync-patches.sh
+++new file mode 100644
+++index 0000000..67d2cc7
+++--- /dev/null
++++++ b/scripts/sync-patches.sh
+++@@ -0,0 +1,56 @@
++++#!/bin/bash
++++
++++# Sync patches directory with current commits
++++# Usage: ./scripts/sync-patches.sh [base-commit]
++++# Default base commit: 2d58e9290237f09c09331383e0416dcb55356450
++++
++++BASE_COMMIT="${1:-be33a66e8c113bb5869cceec1ed6777f0d40ceb8}"
++++PATCHES_DIR="./patches"
++++TEMP_DIR=$(mktemp -d)
++++
++++echo "Syncing patches from base commit: $BASE_COMMIT"
++++
++++# Get list of commits after base commit
++++COMMITS=$(git rev-list "${BASE_COMMIT}..HEAD" --reverse)
++++
++++if [ -z "$COMMITS" ]; then
++++  echo "No new commits since base commit. Patches are up to date."
++++  rm -rf "$TEMP_DIR"
++++  exit 0
++++fi
++++
++++# Generate patches in temporary directory
++++PATCH_NUM=1
++++for commit in $COMMITS; do
++++  # Pad number with zeros for sorting
++++  PADDED_NUM=$(printf "%04d" "$PATCH_NUM")
++++
++++  # Get commit subject for patch filename
++++  SUBJECT=$(git log -1 --format=%s "$commit" | sed 's/[^a-zA-Z0-9-]/-/g; s/-*$//; s/^-*//; s/-{2,}/-/g' | cut -c1-50)
++++
++++  # Ensure subject isn't empty
++++  if [ -z "$SUBJECT" ]; then
++++    SUBJECT="patch-$PATCH_NUM"
++++  fi
++++
++++  PATCH_FILE="${TEMP_DIR}/${PADDED_NUM}-${SUBJECT}.patch"
++++
++++  # Generate patch
++++  git format-patch -1 "$commit" --start-number "$PATCH_NUM" -o "$TEMP_DIR" > /dev/null
++++
++++  PATCH_NUM=$((PATCH_NUM + 1))
++++done
++++
++++# Clean patches directory and copy new patches
++++rm -f "$PATCHES_DIR"/*.patch
++++cp "$TEMP_DIR"/*.patch "$PATCHES_DIR/" 2>/dev/null
++++
++++# List generated patches
++++echo "Generated patches:"
++++ls -1 "$PATCHES_DIR"/*.patch | xargs -n1 basename | sort
++++
++++# Cleanup
++++rm -rf "$TEMP_DIR"
++++
++++echo ""
++++echo " Patches synced successfully!"
+++-- 
+++2.52.0
+++
++diff --git a/patches/0039-add-retry-to-replies-button.patch b/patches/0039-add-retry-to-replies-button.patch
++new file mode 100644
++index 0000000..9be7883
++--- /dev/null
+++++ b/patches/0039-add-retry-to-replies-button.patch
++@@ -0,0 +1,85 @@
+++From ad312ff7a73336affce0cbf1e36c6d91982c924e Mon Sep 17 00:00:00 2001
+++From: Martin Kibera <martin.kibera.n@gmail.com>
+++Date: Sat, 17 Jan 2026 13:25:35 +0300
+++Subject: [PATCH] add retry to replies button
+++
+++---
+++ html/static/js/comments.js | 34 ++++++++++++++++++++++++++++------
+++ 1 file changed, 28 insertions(+), 6 deletions(-)
+++
+++diff --git a/html/static/js/comments.js b/html/static/js/comments.js
+++index 5189537..936832d 100644
+++--- a/html/static/js/comments.js
++++++ b/html/static/js/comments.js
+++@@ -9,14 +9,22 @@ document.querySelectorAll('.comment-reply-count').forEach(replyCountEl => {
+++ 		const commentItem = replyCountEl.closest('.comment-item');
+++ 		const repliesContainer = commentItem.querySelector('.comment-replies-container');
+++ 
+++-		// Toggle if already loaded
++++		if (!repliesContainer) return; // defensive check
++++
++++		// Toggle if already visible
+++ 		if (repliesContainer.style.display !== 'none') {
+++ 			repliesContainer.style.display = 'none';
+++ 			return;
+++ 		}
+++ 
+++ 		// If already has content, just show it
+++-		if (repliesContainer.innerHTML) {
++++		if (repliesContainer.innerHTML && !repliesContainer.classList.contains('error')) {
++++			repliesContainer.style.display = 'block';
++++			return;
++++		}
++++
++++		if (!continuation) {
++++			repliesContainer.innerHTML = '<div class="no-replies" style="padding: 12px; color: #999; font-size: 0.9em;">No replies available</div>';
+++ 			repliesContainer.style.display = 'block';
+++ 			return;
+++ 		}
+++@@ -27,12 +35,23 @@ document.querySelectorAll('.comment-reply-count').forEach(replyCountEl => {
+++ 		replyCountEl.style.opacity = '0.6';
+++ 
+++ 		try {
+++-			const response = await fetch(`/api/comments?v=${encodeURIComponent(videoId)}&continuation=${encodeURIComponent(continuation)}`);
++++			const controller = new AbortController();
++++			const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout
++++
++++			const response = await fetch(
++++				`/api/comments?v=${encodeURIComponent(videoId)}&continuation=${encodeURIComponent(continuation)}`,
++++				{ signal: controller.signal }
++++			);
++++
++++			clearTimeout(timeoutId);
++++
++++			if (!response.ok) throw new Error(`HTTP ${response.status}`);
+++ 			const data = await response.json();
+++ 
+++-			if (!data.comments || data.comments.length === 0) {
++++			if (!data || !Array.isArray(data.comments) || data.comments.length === 0) {
+++ 				repliesContainer.innerHTML = '<div class="no-replies" style="padding: 12px; color: #999; font-size: 0.9em;">No replies available</div>';
+++ 				repliesContainer.style.display = 'block';
++++				repliesContainer.classList.remove('error'); // clear error state
+++ 				return;
+++ 			}
+++ 
+++@@ -56,12 +75,15 @@ document.querySelectorAll('.comment-reply-count').forEach(replyCountEl => {
+++ 			repliesHTML += '</div>';
+++ 			repliesContainer.innerHTML = repliesHTML;
+++ 			repliesContainer.style.display = 'block';
++++			repliesContainer.classList.remove('error');
++++
+++ 		} catch (err) {
+++ 			console.error('Failed to load replies:', err);
+++-			repliesContainer.innerHTML = '<div class="error-replies" style="padding: 12px; color: #e74c3c; font-size: 0.9em;">Failed to load replies</div>';
++++			repliesContainer.innerHTML = '<div class="error-replies" style="padding: 12px; color: #e74c3c; font-size: 0.9em;">Failed to load replies. Click to retry.</div>';
+++ 			repliesContainer.style.display = 'block';
++++			repliesContainer.classList.add('error'); // mark as error
+++ 		} finally {
+++-			// Restore button state
++++			// Restore button so it can be clicked again
+++ 			const replyCount = parseInt(replyCountEl.dataset.replyCount) || 1;
+++ 			const plural = replyCount === 1 ? 'reply' : 'replies';
+++ 			replyCountEl.textContent = `${replyCount} ${plural}`;
+++-- 
+++2.52.0
+++
++diff --git a/patches/0040-update-docker-image-build.patch b/patches/0040-update-docker-image-build.patch
++new file mode 100644
++index 0000000..f67d21c
++--- /dev/null
+++++ b/patches/0040-update-docker-image-build.patch
++@@ -0,0 +1,62 @@
+++From 273921de76243e23b57e17337e172754756f4254 Mon Sep 17 00:00:00 2001
+++From: Martin Kibera <martin.kibera.n@gmail.com>
+++Date: Sat, 17 Jan 2026 14:19:00 +0300
+++Subject: [PATCH] update docker image build
+++
+++---
+++ .dockerignore |  4 ++++
+++ Dockerfile    | 21 ++++++++++++++++-----
+++ 2 files changed, 20 insertions(+), 5 deletions(-)
+++
+++diff --git a/.dockerignore b/.dockerignore
+++index 0214111..3f66c74 100644
+++--- a/.dockerignore
++++++ b/.dockerignore
+++@@ -14,3 +14,7 @@ node_modules
+++ /config/config.js
+++ 
+++ Dockerfile
++++
++++# More unneeded
++++patches
++++scripts/sync-patches.sh
+++\ No newline at end of file
+++diff --git a/Dockerfile b/Dockerfile
+++index cb80a03..ba5fe9d 100644
+++--- a/Dockerfile
++++++ b/Dockerfile
+++@@ -1,14 +1,25 @@
+++-FROM node:14-buster
++++# ---- Build Stage ----
++++FROM node:22-bookworm-slim AS build
+++ 
+++ WORKDIR /workdir
+++ 
+++-COPY package.json ./package.json
+++-COPY package-lock.json ./package-lock.json
++++COPY package.json package-lock.json ./
+++ 
+++-RUN npm install
++++RUN apt-get update && apt-get install -y git python3 build-essential \
++++    && npm install \
++++    && rm -rf /var/lib/apt/lists/*
+++ 
+++ COPY . .
+++ 
++++# ---- Runtime Stage ----
++++FROM node:22-bookworm-slim AS runtime
++++
++++WORKDIR /workdir
++++
++++# Copy only built node_modules and app code
++++COPY --from=build /workdir/node_modules ./node_modules
++++COPY --from=build /workdir ./
++++
+++ EXPOSE 10412
+++ 
+++-CMD npm start
++++CMD ["npm", "start"]
+++\ No newline at end of file
+++-- 
+++2.52.0
+++
++-- 
++2.52.0
++
+diff --git a/patches/0042-improve-audio-buffering.patch b/patches/0042-improve-audio-buffering.patch
+new file mode 100644
+index 0000000..08c1597
+--- /dev/null
++++ b/patches/0042-improve-audio-buffering.patch
+@@ -0,0 +1,73 @@
++From afbf766b44dcec44afe2d76d46ffce2e842020bb Mon Sep 17 00:00:00 2001
++From: Martin Kibera <martin.kibera.n@gmail.com>
++Date: Sat, 17 Jan 2026 19:16:42 +0300
++Subject: [PATCH] improve audio buffering
++
++---
++ html/static/js/player.js | 16 ++++++++++------
++ 1 file changed, 10 insertions(+), 6 deletions(-)
++
++diff --git a/html/static/js/player.js b/html/static/js/player.js
++index ad24b52..59c14f5 100644
++--- a/html/static/js/player.js
+++++ b/html/static/js/player.js
++@@ -293,6 +293,7 @@ const formatLoader = new FormatLoader();
++ 
++ if (formatLoader.npa?.url) {
++     audioElement.src = formatLoader.npa.url;
+++    audioElement.preload = "auto";
++     audioElement.load();
++ }
++ 
++@@ -434,10 +435,8 @@ async function waitForAudioThenPlay(videoEl, audioEl) {
++         return;
++     }
++ 
++-    // Wait until audio has at least one buffered range
+++    // Wait until audio has at least 3s buffered ahead of video
++     await new Promise(resolve => {
++-        if (audioEl.buffered.length > 0) return resolve();
++-
++         const check = () => {
++             if (audioEl.buffered.length > 0) {
++                 const audioEnd = audioEl.buffered.end(audioEl.buffered.length - 1);
++@@ -447,12 +446,16 @@ async function waitForAudioThenPlay(videoEl, audioEl) {
++             }
++             requestAnimationFrame(check);
++         };
++-        requestAnimationFrame(check);
+++        check();
++     });
++ 
++     // Critical: re-check paused state after waiting  browser might have auto-paused or spam happened
++     if (!videoEl.paused) return;
++ 
+++    if (audioEl.readyState < 3) {
+++        await new Promise(res => audioEl.addEventListener('canplay', res, { once: true }));
+++    }
+++
++     // Sync times
++     audioEl.currentTime = videoEl.currentTime;
++ 
++@@ -600,7 +603,8 @@ const debouncedPlayVideo = debounce(async () => {
++     try {
++         if (audioContext.state === 'suspended') await audioContext.resume();
++ 
++-        await waitForAudioThenPlay(videoElement, audioElement);
+++        if (formatLoader.npa) await waitForAudioThenPlay(videoElement, audioElement);
+++        else await videoElement.play();
++     } catch (err) {
++         if (err.name === 'AbortError') {
++             // Expected during rapid seeks  silent ignore
++@@ -732,7 +736,7 @@ if ('mediaSession' in navigator) {
++ }
++ 
++ videoElement.setAttribute('preload', 'metadata');
++-audioElement.setAttribute('preload', 'metadata');
+++//audioElement.setAttribute('preload', 'metadata');
++ 
++ new SubscribeButton(q("#subscribe"));
++ 
++-- 
++2.52.0
++
+-- 
+2.52.0
+
diff --git a/patches/0044-add-music-videos-support.patch b/patches/0044-add-music-videos-support.patch
new file mode 100644
index 0000000..2179e10
--- /dev/null
+++ b/patches/0044-add-music-videos-support.patch
@@ -0,0 +1,49 @@
+From d551b4d84af90be2e766c600c3a30439fa35a32f Mon Sep 17 00:00:00 2001
+From: Martin Kibera <martin.kibera.n@gmail.com>
+Date: Mon, 19 Jan 2026 16:07:55 +0300
+Subject: [PATCH] add music videos support
+
+---
+ README.md    |  1 +
+ api/video.js | 13 +++++++++++--
+ 2 files changed, 12 insertions(+), 2 deletions(-)
+
+diff --git a/README.md b/README.md
+index 2b63a9e..67fdd02 100644
+--- a/README.md
++++ b/README.md
+@@ -11,6 +11,7 @@ Features added:
+ - Timestamp jump fixes.
+ - Uses MediaSession API for external media control.
+ - Comments from invidious API.
++- Music videos. (Needs invidious instance with local proxy enabled).
+ 
+ Notes:
+ - Requires a WORKING invidious instance.
+diff --git a/api/video.js b/api/video.js
+index bf67eb1..81e6d2a 100644
+--- a/api/video.js
++++ b/api/video.js
+@@ -123,8 +123,17 @@ module.exports = [
+ 
+ 			const instanceOrigin = settings.local === 1 ? "http://localhost:3000" : settings.instance;
+ 			const videoFuture = req.method === "GET"
+-				? request(`${instanceOrigin}/api/v1/videos/${id}`).then(res => res.json())
+-				: JSON.parse(new URLSearchParams(body.toString()).get("video"));
++				? (async () => {
++					// Fetch with invidious proxy if Music genre is found
++					let v = await request(`${instanceOrigin}/api/v1/videos/${id}`).then(res => res.json());
++
++					if (v && v.genre === "Music") {
++						v = await request(`${instanceOrigin}/api/v1/videos/${id}?local=1`).then(res => res.json());
++					}
++
++					return v;
++				})()
++				: Promise.resolve(JSON.parse(new URLSearchParams(body.toString()).get("video")));
+ 
+ 			const commentsFuture = request(`${instanceOrigin}/api/v1/comments/${id}`)
+ 				.then(res => res.json())
+-- 
+2.52.0
+
-- 
2.52.0

