From 7538f803d6ae25e6c7e711d6a7458665ef173b93 Mon Sep 17 00:00:00 2001
From: Martin Kibera <martin.kibera.n@gmail.com>
Date: Fri, 24 Oct 2025 11:02:35 +0300
Subject: [PATCH 01/31] stable v1

---
 api/video.js             | 315 ++++++++----------
 html/static/js/player.js | 690 +++++++++++++++++++++++++++------------
 pug/settings.pug         |   5 +-
 3 files changed, 606 insertions(+), 404 deletions(-)

diff --git a/api/video.js b/api/video.js
index 1389c99..859ca0a 100644
--- a/api/video.js
+++ b/api/video.js
@@ -1,246 +1,187 @@
-const {request} = require("../utils/request")
+const {request} = require("../utils/request");
 /** @type {import("node-fetch").default} */
 // @ts-ignore
-const fetch = require("node-fetch")
-const {render} = require("pinski/plugins")
-const db = require("../utils/db")
-const {getToken, getUser} = require("../utils/getuser")
-const pug = require("pug")
-const converters = require("../utils/converters")
-const constants = require("../utils/constants")
+const fetch = require("node-fetch");
+const {render} = require("pinski/plugins");
+const db = require("../utils/db");
+const {getToken, getUser} = require("../utils/getuser");
+const pug = require("pug");
+const converters = require("../utils/converters");
+const constants = require("../utils/constants");
 
 class InstanceError extends Error {
 	constructor(error, identifier) {
-		super(error)
-		this.identifier = identifier
+		super(error);
+		this.identifier = identifier;
 	}
 }
 
-class MessageError extends Error {
-}
+class MessageError extends Error {}
 
 function formatOrder(format) {
-	// most significant to least significant
-	// key, max, order, transform
-	// asc: lower number comes first, desc: higher number comes first
 	const spec = [
-		{key: "second__height", max: 8000, order: "desc", transform: x => x ? Math.floor(x/96) : 0},
-		{key: "fps", max: 100, order: "desc", transform: x => x ? Math.floor(x/10) : 0},
+		{key: "second__height", max: 8000, order: "desc", transform: x => (x ? Math.floor(x / 96) : 0)},
+		{key: "fps", max: 100, order: "desc", transform: x => (x ? Math.floor(x / 10) : 0)},
 		{key: "type", max: " ".repeat(60), order: "asc", transform: x => x.length}
-	]
-	let total = 0
-	for (let i = 0; i < spec.length; i++) {
-		const s = spec[i]
-		let diff = s.transform(format[s.key])
-		if (s.order === "asc") diff = s.transform(s.max) - diff
-		total += diff
-		if (i+1 < spec.length) { // not the last spec item?
-			const s2 = spec[i+1]
-			total *= s2.transform(s2.max)
+	];
+
+	return spec.reduce((total, s, i) => {
+		let diff = s.transform(format[s.key]);
+		if (s.order === "asc") diff = s.transform(s.max) - diff;
+		total += diff;
+		if (i + 1 < spec.length) {
+			total *= spec[i + 1].transform(spec[i + 1].max);
 		}
-	}
-	return -total
+		return total;
+	}, 0) * -1;
 }
 
 function sortFormats(video, preference) {
-	// Add second__ extensions to format objects, required if Invidious was the extractor
-	let formats = video.formatStreams.concat(video.adaptiveFormats)
-	for (const format of formats) {
-		if (!format.second__height && format.resolution) format.second__height = +format.resolution.slice(0, -1)
-		if (!format.second__order) format.second__order = formatOrder(format)
-		format.cloudtube__label = `${format.qualityLabel} ${format.container}`
-	}
+	const {formatStreams, adaptiveFormats} = video;
+	let formats = [...formatStreams, ...adaptiveFormats];
 
-	// Properly build and order format list
-	const standard = video.formatStreams.slice().sort((a, b) => b.second__height - a.second__height)
-	const adaptive = video.adaptiveFormats.filter(f => f.type.startsWith("video") && f.qualityLabel).sort((a, b) => a.second__order - b.second__order)
-	for (const format of adaptive) {
-		if (!format.cloudtube__label.endsWith("*")) format.cloudtube__label += " *"
-	}
-	formats = standard.concat(adaptive)
-
-	// Reorder fomats based on user preference
-	if (preference === 1) { // best dash
-		formats.sort((a, b) => {
-			const a1 = a.second__height + a.fps / 100
-			const b1 = b.second__height + b.fps / 100
-			return b1 - a1
-		})
-	} else if (preference === 2) { // best <=1080p
-		formats.sort((a, b) => {
-			const a1 = a.second__height + a.fps / 100
-			const b1 = b.second__height + b.fps / 100
-			if (b1 > 1081) {
-				if (a1 > 1081) return b1 - a1
-				return -1
-			}
-			if (a1 > 1081) return 1
-			return b1 - a1
-		})
-	} else if (preference === 3) { // best low-fps
-		formats.sort((a, b) => {
-			if (b.fps > 30) {
-				if (a.fps < 30) return b.second__height - a.second__height
-				return -1
-			}
-			if (a.fps > 30) return 1
-			return b.second__height - a.second__height
-		})
-	} else if (preference === 4) { // 360p only
-		formats.sort((a, b) => {
-			if (a.itag == 18) return -1
-			if (b.itag == 18) return 1
-			return 0
-		})
-	} else { // preference === 0, best combined
-		// should already be correct
+	formats.forEach(format => {
+		if (!format.second__height && format.resolution) {
+			format.second__height = +format.resolution.slice(0, -1);
+		}
+		if (!format.second__order) {
+			format.second__order = formatOrder(format);
+		}
+		format.cloudtube__label = `${format.qualityLabel} ${format.container}`;
+	});
+
+	const standard = [...formatStreams].sort((a, b) => b.second__height - a.second__height);
+	const adaptive = adaptiveFormats
+		.filter(f => f.type.startsWith("video") && f.qualityLabel)
+		.map(f => ({...f, cloudtube__label: `${f.cloudtube__label} *`}))
+		.sort((a, b) => a.second__order - b.second__order);
+
+	formats = [...standard, ...adaptive];
+
+	const preferenceSorters = {
+		5: (a, b) => (b.second__height + b.fps / 100) - (a.second__height + a.fps / 100),
+		2: (a, b) => {
+			const a1 = a.second__height + a.fps / 100;
+			const b1 = b.second__height + b.fps / 100;
+			if (b1 > 1081) return a1 > 1081 ? b1 - a1 : -1;
+			if (a1 > 1081) return 1;
+			return b1 - a1;
+		},
+		1: (a, b) => {
+			const a1 = a.second__height + a.fps / 100;
+			const b1 = b.second__height + b.fps / 100;
+			if (b1 > 721) return a1 > 721 ? b1 - a1 : -1;
+			if (a1 > 721) return 1;
+			return b1 - a1;
+		},
+		3: (a, b) => {
+			if (b.fps > 30) return a.fps < 30 ? b.second__height - a.second__height : -1;
+			if (a.fps > 30) return 1;
+			return b.second__height - a.second__height;
+		},
+		4: (a, b) => (a.itag === 18 ? -1 : b.itag === 18 ? 1 : 0)
+	};
+
+	if (preference in preferenceSorters) {
+		formats.sort(preferenceSorters[preference]);
 	}
 
-	return formats
+	return formats;
 }
 
 module.exports = [
 	{
 		route: "/watch", methods: ["GET", "POST"], upload: true, code: async ({req, url, body}) => {
-			// Prepare data needed to render video page
-
-			const user = getUser(req)
-			const settings = user.getSettingsOrDefaults()
-			const id = url.searchParams.get("v")
+			const user = getUser(req);
+			const settings = user.getSettingsOrDefaults();
+			const id = url.searchParams.get("v");
 
-			// Check if should watch on YouTube
 			if (settings.local === 2) {
-				const dest = `https://www.youtube.com${url.pathname}${url.search}#cloudtube`
-				user.addWatchedVideoMaybe(id)
+				const dest = `https://www.youtube.com${url.pathname}${url.search}#cloudtube`;
+				user.addWatchedVideoMaybe(id);
 				return {
 					statusCode: 302,
 					contentType: "text/plain",
-					headers: {
-						"Location": dest
-					},
+					headers: {"Location": dest},
 					content: `Redirecting to ${dest}...`
-				}
+				};
 			}
 
-			// Check if playback is allowed
-			const videoTakedownInfo = db.prepare("SELECT id, org, url FROM TakedownVideos WHERE id = ?").get(id)
+			const videoTakedownInfo = db.prepare("SELECT id, org, url FROM TakedownVideos WHERE id = ?").get(id);
 			if (videoTakedownInfo) {
-				return render(451, "pug/takedown-video.pug", Object.assign({req, settings}, videoTakedownInfo))
+				return render(451, "pug/takedown-video.pug", {...videoTakedownInfo, req, settings});
 			}
 
-			// Media fragment
-			const t = url.searchParams.get("t")
-			let mediaFragment = converters.tToMediaFragment(t)
-
-			// Continuous mode
-			const continuous = url.searchParams.get("continuous") === "1"
-			const autoplay = url.searchParams.get("autoplay") === "1"
-			const swp = url.searchParams.get("session-watched")
-			const sessionWatched = swp ? swp.split(" ") : []
-			const sessionWatchedNext = sessionWatched.concat([id]).join("+")
-			if (continuous) settings.quality = 0 // autoplay with synced streams does not work
-
-			// Work out how to fetch the video
-			if (req.method === "GET") {
-				if (settings.local === 1) { // skip to the local fetching page, which will then POST video data in a moment
-					return render(200, "pug/local-video.pug", {req, settings, id})
-				}
-				var instanceOrigin = settings.instance
-				var outURL = `${instanceOrigin}/api/v1/videos/${id}`
-				var videoFuture = request(outURL).then(res => res.json())
-			} else { // req.method === "POST"
-				var instanceOrigin = "http://localhost:3000"
-				var videoFuture = JSON.parse(new URLSearchParams(body.toString()).get("video"))
-			}
+			const t = url.searchParams.get("t");
+			const mediaFragment = converters.tToMediaFragment(t);
+			const continuous = url.searchParams.get("continuous") === "1";
+			const autoplay = url.searchParams.get("autoplay") === "1";
+			const swp = url.searchParams.get("session-watched");
+			const sessionWatched = swp ? swp.split(" ") : [];
+			const sessionWatchedNext = [...sessionWatched, id].join("+");
+			if (continuous) settings.quality = 0;
 
-			try {
-				// Fetch the video
-				const video = await videoFuture
+			const instanceOrigin = settings.local === 1 ? "http://localhost:3000" : settings.instance;
+			const videoFuture = req.method === "GET"
+				? request(`${instanceOrigin}/api/v1/videos/${id}`).then(res => res.json())
+				: JSON.parse(new URLSearchParams(body.toString()).get("video"));
 
-				// Error handling
-				if (!video) throw new MessageError("The instance returned null.")
-				if (video.error) throw new InstanceError(video.error, video.identifier)
+			try {
+				const video = await videoFuture;
+				if (!video) throw new MessageError("The instance returned null.");
+				if (video.error) throw new InstanceError(video.error, video.identifier);
 
-				// Check if channel playback is allowed
-				const channelTakedownInfo = db.prepare("SELECT ucid, org, url FROM TakedownChannels WHERE ucid = ?").get(video.authorId)
+				const channelTakedownInfo = db.prepare("SELECT ucid, org, url FROM TakedownChannels WHERE ucid = ?").get(video.authorId);
 				if (channelTakedownInfo) {
-					// automatically add the entry to the videos list, so it won't be fetched again
-					const args = {id, ...channelTakedownInfo}
-					db.prepare("INSERT INTO TakedownVideos (id, org, url) VALUES (@id, @org, @url)").run(args)
-					return render(451, "pug/takedown-video.pug", Object.assign({req, settings}, channelTakedownInfo))
-				}
-
-				// process stream list ordering
-				const formats = sortFormats(video, settings.quality)
-
-				// process length text and view count
-				for (const rec of video.recommendedVideos) {
-					converters.normaliseVideoInfo(rec)
+					db.prepare("INSERT INTO TakedownVideos (id, org, url) VALUES (@id, @org, @url)").run({id, ...channelTakedownInfo});
+					return render(451, "pug/takedown-video.pug", {...channelTakedownInfo, req, settings});
 				}
 
-				// filter list
-				const {videos, filteredCount} = converters.applyVideoFilters(video.recommendedVideos, user.getFilters())
-				video.recommendedVideos = videos
+				const formats = sortFormats(video, settings.quality);
 
-				// get subscription data
-				const subscribed = user.isSubscribed(video.authorId)
+				video.recommendedVideos.forEach(converters.normaliseVideoInfo);
+				const {videos, filteredCount} = converters.applyVideoFilters(video.recommendedVideos, user.getFilters());
+				video.recommendedVideos = videos;
 
-				// process watched videos
-				user.addWatchedVideoMaybe(video.videoId)
-				const watchedVideos = user.getWatchedVideos()
+				const subscribed = user.isSubscribed(video.authorId);
+				user.addWatchedVideoMaybe(video.videoId);
+				const watchedVideos = user.getWatchedVideos();
 				if (watchedVideos.length) {
-					for (const rec of video.recommendedVideos) {
-						rec.watched = watchedVideos.includes(rec.videoId)
-					}
+					video.recommendedVideos.forEach(rec => {
+						rec.watched = watchedVideos.includes(rec.videoId);
+					});
 				}
 
-				// normalise view count
 				if (!video.second__viewCountText && video.viewCount) {
-					video.second__viewCountText = converters.viewCountToText(video.viewCount)
+					video.second__viewCountText = new Intl.NumberFormat().format(video.viewCount);
 				}
 
-				// apply media fragment to all sources
-				for (const format of formats) {
-					format.url += mediaFragment
-				}
+				formats.forEach(format => {
+					format.url += mediaFragment;
+				});
 
-				// rewrite description
-				video.descriptionHtml = converters.rewriteVideoDescription(video.descriptionHtml, id)
-
-				// rewrite captions urls so they are served on the same domain via the /proxy route
-				for (const caption of video.captions) {
-					caption.url = `/proxy?${new URLSearchParams({"url": caption.url})}`
-				}
+				video.descriptionHtml = converters.rewriteVideoDescription(video.descriptionHtml, id);
+				video.captions.forEach(caption => {
+					caption.url = `/proxy?${new URLSearchParams({url: caption.url})}`;
+				});
 
 				return render(200, "pug/video.pug", {
 					req, url, video, formats, subscribed, instanceOrigin, mediaFragment, autoplay, continuous,
 					sessionWatched, sessionWatchedNext, settings
-				})
+				});
 
 			} catch (error) {
-				// Something went wrong, somewhere! Find out where.
-
-				let errorType = "unrecognised-error"
-				const locals = {instanceOrigin, error}
-
-				// Sort error category
-				if (error instanceof fetch.FetchError) {
-					errorType = "fetch-error"
-				} else if (error instanceof MessageError) {
-					errorType = "message-error"
-				} else if (error instanceof InstanceError) {
-					if (error.identifier === "RATE_LIMITED_BY_YOUTUBE" || error.message === "Could not extract video info. Instance is likely blocked.") {
-						errorType = "rate-limited"
-					} else {
-						errorType = "instance-error"
-					}
-				}
-
-				// Create appropriate formatted message
-				const message = render(0, `pug/errors/${errorType}.pug`, locals).content
-
-				return render(500, "pug/video.pug", {video: {videoId: id}, error: true, message, req, settings})
+				const errorTypeMap = {
+					"fetch-error": error instanceof fetch.FetchError,
+					"message-error": error instanceof MessageError,
+					"rate-limited": error instanceof InstanceError && (error.identifier === "RATE_LIMITED_BY_YOUTUBE" || error.message === "Could not extract video info. Instance is likely blocked."),
+					"instance-error": error instanceof InstanceError
+				};
+				const errorType = Object.keys(errorTypeMap).find(key => errorTypeMap[key]) || "unrecognised-error";
+				const message = render(0, `pug/errors/${errorType}.pug`, {instanceOrigin, error}).content;
+
+				return render(500, "pug/video.pug", {video: {videoId: id}, error: true, message, req, settings});
 			}
 		}
 	}
-]
+];
\ No newline at end of file
diff --git a/html/static/js/player.js b/html/static/js/player.js
index f053224..3fff9d9 100644
--- a/html/static/js/player.js
+++ b/html/static/js/player.js
@@ -1,250 +1,510 @@
-import {q, qa, ElemJS} from "/static/js/elemjs/elemjs.js"
-import {SubscribeButton} from "/static/js/modules/SubscribeButton.js"
+import { q, qa, ElemJS } from "/static/js/elemjs/elemjs.js";
+import { SubscribeButton } from "/static/js/modules/SubscribeButton.js";
 
-const video = q("#video")
-const audio = q("#audio")
+const videoElement = q("#video");
+const audioElement = q("#audio");
+// Buffer audio aggressively
+audioElement.preload = "auto";
 
-const videoFormats = new Map()
-const audioFormats = new Map()
-for (const f of [].concat(
-	data.formatStreams.map(f => (f.isAdaptive = false, f)),
-	data.adaptiveFormats.map(f => (f.isAdaptive = true, f))
-)) {
-	if (f.type.startsWith("video")) {
-		videoFormats.set(f.itag, f)
-	} else {
-		audioFormats.set(f.itag, f)
-	}
-}
+// Make video focusable
+videoElement.setAttribute("tabindex", "0");
+
+let userInteracted = false;
+document.addEventListener("click", () => { userInteracted = true; }, { once: true });
+
+let syncCheckInterval = null;
+const videoFormats = new Map();
+const audioFormats = [];
+
+[...data.formatStreams, ...data.adaptiveFormats].forEach(f => {
+    f.isAdaptive = f.type.startsWith("video");
+    if (f.type.startsWith("video")) {
+        videoFormats.set(f.itag, f);
+    } else {
+        audioFormats.push(f);
+    }
+});
 
 function getBestAudioFormat() {
-	let best = null
-	let aidub = false
-	for (const f of audioFormats.values()) {
-		if (f.resolution.includes("default")) {
-			aidub = true
-		}
-	}
-	for (const f of audioFormats.values()) {
-		if (!aidub || f.resolution.includes("default")) {
-			if (best === null || f.bitrate > best.bitrate) {
-				best = f
-			}
-		}
-	}
-	return best
+    function parseXtags(url) {
+        const urlParams = new URLSearchParams(url.split('?')[1] ?? '');
+        const xtags = urlParams.get('xtags') ?? '';
+        const parts = xtags.split(':');
+        let language = 'unknown';
+        let content = 'unknown';
+        for (const part of parts) {
+            if (part.startsWith('lang=')) {
+                language = part.replace('lang=', '');
+                if (language.includes('-')) language = language.split('-')[0];
+            }
+            if (part.startsWith('acont=')) content = part.replace('acont=', '');
+        }
+        return { language, content };
+    }
+
+    let best = null;
+
+    for (const f of audioFormats) {
+        if (!isValidUrl(f.url)) continue;
+        const { language, content } = parseXtags(f.url);
+        if (language === 'en' && content === 'original') {
+            if (!best || f.bitrate > best.bitrate) {
+                best = f;
+            }
+        }
+    }
+
+    if (!best) {
+        for (const f of audioFormats) {
+            if (!isValidUrl(f.url)) continue;
+            const { language } = parseXtags(f.url);
+            if (language === 'en') {
+                if (!best || f.bitrate > best.bitrate) {
+                    best = f;
+                }
+            }
+        }
+    }
+
+    if (!best) {
+        for (const f of audioFormats) {
+            if (!isValidUrl(f.url)) continue;
+            if (!best || f.bitrate > best.bitrate) {
+                best = f;
+            }
+        }
+    }
+
+    return best;
+}
+
+function isValidUrl(string) {
+    try {
+        new URL(string);
+        return true;
+    } catch (_) {
+        return false;
+    }
+}
+
+function loadMediaWithRetry(mediaElement, url, retries = 6) {
+    let attempt = 0;
+    let locked = false; // lock once playback ever begins
+
+    const load = () => {
+        if (locked) return; // never reload after playback has started
+
+        mediaElement.src = url;
+        mediaElement.load();
+
+        // Lock out retries once playback begins
+        mediaElement.onplaying = () => {
+            locked = true;
+        };
+
+        mediaElement.oncanplay = () => {
+            // Also lock out once itâ€™s ready to play (in case play() isnâ€™t called yet)
+            locked = true;
+        };
+
+        mediaElement.onerror = () => {
+            if (locked) return; // ignore errors after lock
+
+            attempt++;
+            if (attempt < retries) {
+                setTimeout(load, 4000 * attempt);
+            } else {
+                console.error("Failed to load media after", retries, "attempts.");
+            }
+        };
+    };
+
+    load();
 }
 
+let pipReady = false;
+
+document.addEventListener("visibilitychange", async () => {
+    const video = document.querySelector("video");
+    if (!video || !document.pictureInPictureEnabled) return;
+
+    if (document.hidden && !document.pictureInPictureElement && !video.paused) {
+        if (!pipReady) {
+            console.warn("PiP blocked. Waiting for user gesture to enable re-entry.");
+            return;
+        }
+
+        try {
+            await video.requestPictureInPicture();
+        } catch (err) {
+            console.error("PiP request failed:", err);
+        }
+    }
+});
+
+document.addEventListener("leavepictureinpicture", () => {
+    pipReady = false;
+});
+
+document.addEventListener("click", () => {
+    pipReady = true;
+});
+
+const audioContext = new AudioContext();
+
 class FormatLoader {
-	constructor() {
-		this.npv = videoFormats.get(q("#video").getAttribute("data-itag"))
-		this.npa = null
-	}
-
-	play(itag) {
-		this.npv = videoFormats.get(itag)
-		if (this.npv.isAdaptive) {
-			this.npa = getBestAudioFormat()
-		} else {
-			this.npa = null
-		}
-		this.update()
-	}
-
-	update() {
-		const lastTime = video.currentTime
-		video.src = this.npv.url
-		video.currentTime = lastTime
-		if (this.npa) {
-			audio.src = this.npa.url
-			audio.pause()
-			audio.currentTime = lastTime
-		} else {
-			audio.pause()
-			audio.removeAttribute("src")
-		}
-	}
-}
-
-const formatLoader = new FormatLoader()
+    constructor() {
+        this.npv = videoFormats.get(videoElement.getAttribute("data-itag"));
+        this.npa = null;
+    }
+
+    play(itag) {
+        this.npv = videoFormats.get(itag);
+        this.npa = null;
+
+        // Only attach separate audio if the stream has no audio codec
+        const hasAudio = this.npv.type && (this.npv.type.includes("mp4a") || this.npv.type.includes("audio"));
+        if (!hasAudio) {
+            const bestAudio = getBestAudioFormat();
+            if (bestAudio && bestAudio.url !== this.npv.url) {
+                this.npa = bestAudio;
+            }
+        }
+
+        this.update();
+    }
+
+    update() {
+        cleanupSync();
+        const lastTime = videoElement.currentTime;
+
+        loadMediaWithRetry(videoElement, this.npv.url);
+        videoElement.currentTime = lastTime;
+
+        if (this.npa) {
+            audioElement.pause();
+            audioElement.src = "";
+            loadMediaWithRetry(audioElement, this.npa.url);
+            audioElement.currentTime = lastTime;
+        } else {
+            audioElement.pause();
+            audioElement.removeAttribute("src");
+        }
+    }
+}
+
+
+const formatLoader = new FormatLoader();
 
 class PlayManager {
-	constructor(media, isAudio) {
-		this.media = media
-		this.isAudio = isAudio
-	}
+    constructor(media, isAudio) {
+        this.media = media;
+        this.isAudio = isAudio;
+    }
 
-	isActive() {
-		return !this.isAudio || formatLoader.npa
-	}
+    isActive() {
+        return !this.isAudio || formatLoader.npa;
+    }
 
-	play() {
-		if (this.isActive()) this.media.play()
-	}
+    play() {
+        if (this.isActive()) this.media.play();
+    }
 
-	pause() {
-		if (this.isActive()) this.media.pause()
-	}
+    pause() {
+        if (this.isActive()) this.media.pause();
+    }
 }
 
 const playManagers = {
-	video: new PlayManager(video, false),
-	audio: new PlayManager(audio, true)
-}
+    video: new PlayManager(videoElement, false),
+    audio: new PlayManager(audioElement, true)
+};
 
 class QualitySelect extends ElemJS {
-	constructor() {
-		super(q("#quality-select"))
-		this.on("input", this.setFormat.bind(this))
-		this.setFormat()
-	}
+    constructor() {
+        super(q("#quality-select"));
+        this.on("input", this.setFormat.bind(this));
+        this.setFormat();
+    }
+
+    setFormat() {
+        const itag = this.element.value;
+        formatLoader.play(itag);
+        videoElement.focus();
+    }
+}
+
+new QualitySelect();
 
-	setFormat() {
-		const itag = this.element.value
-		formatLoader.play(itag)
-		video.focus()
-	}
+const ignoreNext = { play: 0 };
+
+function startSyncCheck() {
+    if (syncCheckInterval) clearInterval(syncCheckInterval);
+    syncCheckInterval = setInterval(() => {
+        if (!videoElement.paused && !audioElement.paused) {
+            const drift = Math.abs(videoElement.currentTime - audioElement.currentTime);
+            if (drift > 0.1) {
+                audioElement.currentTime = videoElement.currentTime;
+            }
+        }
+    }, 1000);
 }
 
-const qualitySelect = new QualitySelect()
+function stopSyncCheck() {
+    if (syncCheckInterval) clearInterval(syncCheckInterval);
+    syncCheckInterval = null;
+}
 
-const ignoreNext = {
-	play: 0
+function cleanupSync() {
+    stopSyncCheck();
 }
 
+videoElement.addEventListener("play", startSyncCheck);
+videoElement.addEventListener("pause", stopSyncCheck);
+
+// --- SponsorBlock skip fix
+let sponsorSkipInProgress = false; // flag to track SB skip
+
+// Wrap SponsorBlock skips by listening for its events
+document.addEventListener("SponsorBlockSkip", () => {
+    sponsorSkipInProgress = true;
+    setTimeout(() => { sponsorSkipInProgress = false; }, 100); // short debounce
+});
+
 function playbackIntervention(event) {
-	console.log(event.target.tagName.toLowerCase(), event.type)
-	if (audio.src) {
-		let target = event.target
-		let other = (event.target === video ? audio : video)
-		let targetPlayManager = playManagers[target.tagName.toLowerCase()]
-		let otherPlayManager = playManagers[other.tagName.toLowerCase()]
-		if (ignoreNext[event.type] > 0) {
-			ignoreNext[event.type]--
-			return
-		}
-		switch (event.type) {
-		case "durationchange":
-			target.ready = false;
-			break;
-		case "seeked":
-			target.ready = false;
-			target.pause();
-			other.currentTime = target.currentTime;
-			break;
-		case "play":
-			other.currentTime = target.currentTime;
-			otherPlayManager.play();
-			break;
-		case "pause":
-			other.currentTime = target.currentTime;
-			other.pause();
-		case "playing":
-			other.currentTime = target.currentTime;
-			break;
-		case "ratechange":
-			other.playbackRate = target.playbackRate;
-			break;
-		// case "stalled":
-		// case "waiting":
-			// target.pause();
-			// break;
-		}
-	} else {
-		// @ts-ignore this does exist
-		// if (event.type == "canplaythrough" && !video.manualPaused) video.play();
-	}
-}
-
-for (let eventName of ["pause", "play", "seeked"]) {
-	video.addEventListener(eventName, playbackIntervention)
-}
-for (let eventName of ["canplaythrough", "waiting", "stalled", "ratechange"]) {
-	video.addEventListener(eventName, playbackIntervention)
-	audio.addEventListener(eventName, playbackIntervention)
+    const target = event.target;
+    const other = target === videoElement ? audioElement : videoElement;
+
+    // Only sync audio for non-SB manual seeks
+    if (!sponsorSkipInProgress && audioElement.src && !ignoreNext[event.type]--) {
+        if (event.type === "seeked") {
+            const targetTime = target.currentTime;
+            other.currentTime = targetTime;
+
+            setTimeout(() => {
+                if (Math.abs(videoElement.currentTime - audioElement.currentTime) > 0.1) {
+                    videoElement.currentTime = targetTime;
+                    audioElement.currentTime = targetTime;
+                }
+            }, 100);
+        } else if (event.type === "play") {
+            playManagers[other.tagName.toLowerCase()].play();
+        } else if (event.type === "pause") {
+            other.pause();
+        } else if (event.type === "ratechange") {
+            other.playbackRate = target.playbackRate;
+        }
+    }
 }
 
+function debounce(func, wait) {
+    let timeoutId;
+    return (...args) => {
+        clearTimeout(timeoutId);
+        timeoutId = setTimeout(() => func(...args), wait);
+    };
+}
+
+const debouncedPlaybackIntervention = debounce(playbackIntervention, 100);
+["pause", "play", "seeked"].forEach(eventName =>
+    videoElement.addEventListener(eventName, debouncedPlaybackIntervention)
+);
+["canplaythrough", "waiting", "stalled", "ratechange"].forEach(eventName => {
+    videoElement.addEventListener(eventName, playbackIntervention);
+    audioElement.addEventListener(eventName, playbackIntervention);
+});
+
+// Error handling
+videoElement.addEventListener("error", (e) => {
+    console.error("Video loading error:", e);
+});
+audioElement.addEventListener("error", (e) => {
+    console.error("Audio loading error:", e);
+});
+
+// Loading feedback
+videoElement.addEventListener("waiting", () => console.log("Video buffering..."));
+audioElement.addEventListener("waiting", () => console.log("Audio buffering..."));
+
+// Fix reverb on buffering mid-playback
+// --- Robust mid-playback buffering isolation ---
+let wasPlayingBeforeBuffer = false;
+
+videoElement.addEventListener("waiting", () => {
+    if (!videoElement.paused && videoElement.currentTime > 0) {
+        wasPlayingBeforeBuffer = true;
+
+        if (!audioElement.paused && formatLoader.npa) {
+            audioElement.muted = true;
+        }
+    }
+});
+
+videoElement.addEventListener("playing", () => {
+    if (wasPlayingBeforeBuffer && formatLoader.npa) {
+        wasPlayingBeforeBuffer = false;
+        audioElement.muted = false;
+        audioElement.currentTime = videoElement.currentTime;
+    }
+});
+
+
+const videoObserver = new IntersectionObserver((entries) => {
+    entries.forEach(entry => {
+        if (entry.isIntersecting) {
+            loadMediaWithRetry(videoElement, formatLoader.npv.url);
+            if (formatLoader.npa) {
+                loadMediaWithRetry(audioElement, formatLoader.npa.url);
+            }
+            videoObserver.disconnect();
+        }
+    });
+}, { threshold: 0.5 });
+
+videoObserver.observe(videoElement);
+
 function relativeSeek(seconds) {
-	video.currentTime += seconds
+    videoElement.currentTime += seconds;
 }
 
-function playVideo() {
-	audio.currentTime = video.currentTime
-	let lastTime = video.currentTime
-	ignoreNext.play++
-	video.play().then(() => {
-		const interval = setInterval(() => {
-			console.log("checking video", video.currentTime, lastTime)
-			if (video.currentTime !== lastTime) {
-				clearInterval(interval)
-				playManagers.audio.play()
-				return
-			}
-		}, 15)
-	})
+async function playVideo() {
+    if (!userInteracted) return; // ðŸ”´ prevent auto play before click/gesture
+    if (!videoElement.paused) return;
+
+    audioElement.currentTime = videoElement.currentTime;
+    ignoreNext.play++;
+
+    try {
+        if (audioContext.state === 'suspended') {
+            await audioContext.resume();
+        }
+
+        await videoElement.play();
+        if (playManagers.audio.isActive() && audioElement.src) {
+            await audioElement.play();
+        }
+    } catch (e) {
+        console.error("Video play failed", e);
+    }
 }
 
 function togglePlaying() {
-	if (video.paused) playVideo()
-	else video.pause()
+    if (videoElement.paused) {
+        playVideo();
+    } else {
+        videoElement.pause();
+    }
 }
 
 function toggleFullScreen() {
-	if (document.fullscreen) document.exitFullscreen()
-	else video.requestFullscreen()
-}
-
-video.addEventListener("click", event => {
-	event.preventDefault()
-	togglePlaying()
-})
-
-video.addEventListener("dblclick", event => {
-	event.preventDefault()
-	toggleFullScreen()
-})
-
-document.addEventListener("keydown", event => {
-	if (["INPUT", "SELECT", "BUTTON"].includes(event.target.tagName)) return
-	if (event.ctrlKey || event.shiftKey || event.altKey || event.metaKey) return
-	let caught = true
-	if (event.key === "j" || event.key === "n") {
-		relativeSeek(-10)
-	} else if (["k", "p", " ", "e"].includes(event.key)) {
-		togglePlaying()
-	} else if (event.key === "l" || event.key === "o") {
-		relativeSeek(10)
-	} else if (event.key === "ArrowLeft") {
-		relativeSeek(-5)
-	} else if (event.key === "ArrowRight") {
-		relativeSeek(5)
-	} else if (event.key >= "0" && event.key <= "9") {
-		video.currentTime = video.duration * (+event.key) / 10
-	} else if (event.key === "f") {
-		toggleFullScreen()
-	} else {
-		caught = false
-	}
-	if (caught) event.preventDefault()
-})
-
-new SubscribeButton(q("#subscribe"))
-
-const timestamps = qa("[data-clickable-timestamp]")
-
-class Timestamp extends ElemJS {
-	constructor(element) {
-		super(element)
-		this.on("click", this.onClick.bind(this))
-	}
-
-	onClick(event) {
-		event.preventDefault()
-		video.currentTime = event.target.getAttribute("data-clickable-timestamp")
-		window.history.replaceState(null, "", event.target.href)
-	}
-}
-
-timestamps.forEach(el => {
-	new Timestamp(el)
-})
+    if (document.fullscreenElement || document.webkitFullscreenElement) {
+        (document.exitFullscreen || document.webkitExitFullscreen).call(document);
+    } else {
+        (videoElement.requestFullscreen || videoElement.webkitRequestFullscreen).call(videoElement);
+    }
+}
+
+// ðŸ”´ Critical: Track interaction and refocus
+videoElement.addEventListener("pointerdown", () => {
+    videoElement.focus();
+});
+
+videoElement.addEventListener("click", (event) => {
+    event.preventDefault();
+    togglePlaying();
+    videoElement.lastInteraction = Date.now(); // Track last click
+    videoElement.focus();
+});
+
+// âœ… Capture spacebar early and forcefully
+const keyActions = new Map([
+    ["j", () => relativeSeek(-10)],
+    ["n", () => relativeSeek(-10)],
+    ["k", togglePlaying],
+    ["p", togglePlaying],
+    [" ", togglePlaying],
+    ["e", togglePlaying],
+    ["l", () => relativeSeek(10)],
+    ["o", () => relativeSeek(10)],
+    ["ArrowLeft", () => relativeSeek(-5)],
+    ["ArrowRight", () => relativeSeek(5)],
+    ["f", toggleFullScreen]
+]);
+
+// Use capture phase to intercept spacebar before browser scrolls
+document.addEventListener("keydown", async (event) => {
+    // Ignore inputs and Ctrl combinations
+    if (["INPUT", "SELECT", "TEXTAREA", "BUTTON"].includes(event.target.tagName) || event.ctrlKey) {
+        return;
+    }
+
+    if (event.key === "k") {
+        event.preventDefault();
+
+        // Track last interaction so other logic (like spacebar) sees a gesture
+        videoElement.lastInteraction = Date.now();
+
+        // Attempt to play video and audio
+        try {
+            if (videoElement.paused) {
+                await videoElement.play(); // counts as user gesture
+                if (audioElement.src && playManagers.audio.isActive()) {
+                    try {
+                        await audioElement.play();
+                    } catch (e) {
+                        console.warn("Audio blocked until user gesture:", e);
+                    }
+                }
+            } else {
+                videoElement.pause();
+                audioElement.pause();
+            }
+        } catch (e) {
+            console.warn("Playback blocked by browser:", e);
+        }
+
+        return; // prevent further handling
+    }
+
+    const action = keyActions.get(event.key);
+    if (action) {
+        if (event.key === " ") {
+            const isActive = document.activeElement === videoElement;
+            const recentlyClicked = Date.now() - (videoElement.lastInteraction || 0) < 15000;
+            if (!isActive && !recentlyClicked) return;
+            event.preventDefault();
+        }
+
+        action();
+        event.preventDefault();
+    }
+}, true); // capture phase: critical for gesture detection
+
+
+if ('mediaSession' in navigator) {
+    navigator.mediaSession.metadata = new MediaMetadata({
+        title: 'Video Title',
+        artist: 'Artist Name',
+        album: 'Album Name',
+    });
+
+    navigator.mediaSession.setActionHandler('play', togglePlaying);
+    navigator.mediaSession.setActionHandler('pause', togglePlaying);
+}
+
+videoElement.setAttribute('preload', 'metadata');
+audioElement.setAttribute('preload', 'metadata');
+
+new SubscribeButton(q("#subscribe"));
+
+document.addEventListener('click', (event) => {
+    const timestampEl = event.target.closest('[data-clickable-timestamp]');
+    if (timestampEl) {
+        event.preventDefault();
+        const time = parseFloat(timestampEl.getAttribute('data-clickable-timestamp'));
+        if (!isNaN(time)) {
+            videoElement.currentTime = time;
+            window.history.replaceState(null, '', timestampEl.href);
+        }
+    }
+});
\ No newline at end of file
diff --git a/pug/settings.pug b/pug/settings.pug
index f504dba..d56de25 100644
--- a/pug/settings.pug
+++ b/pug/settings.pug
@@ -71,9 +71,10 @@ block content
           label: "Preferred qualities",
           description: "All qualities are available on the watch page. This defines their sort order.",
           options: [
+            {value: "1", text: "b720p"},
             {value: "0", text: "720p"},
             {value: "4", text: "360p"},
-            {value: "1", text: "Best possible"},
+            {value: "5", text: "Best possible"},
             {value: "2", text: "Best <=1080p"},
             {value: "3", text: "Best <=30fps"}
           ]
@@ -137,4 +138,4 @@ block content
           label(for="delete-confirm").delete-confirm-label I understand the consequences
         form(method="post" action="/formapi/erase")
           input(type="hidden" name="token" value=user.token)
-          button.border-look#delete-button Permanently erase my data
+          button.border-look#delete-button Permanently erase my data
\ No newline at end of file
-- 
2.52.0

